---
author: stevewhims
description: Die Tabelle mit den Symptomen und Problembehandlungen in diesem Thema kann für Sie hilfreich sein, egal ob Sie neuen Code schreiben oder eine bestehende App portieren.
title: Problembehandlung bei C++/WinRT-Problemen
ms.author: stwhi
ms.date: 05/07/2018
ms.topic: article
keywords: windows 10, uwp, standard, c++, cpp, winrt, projizierung, problembehandlung, HRESULT, fehler
ms.localizationpriority: medium
ms.openlocfilehash: f1a25b606def215defb8be0e0a38c628349f2440
ms.sourcegitcommit: 3257416aebb5a7b1515e107866806f8bd57845a8
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 11/16/2018
ms.locfileid: "7147986"
---
# <a name="troubleshooting-cwinrt-issues"></a>Problembehandlung bei C++/WinRT-Problemen

> [!NOTE]
> Informationen zur Installation und Verwendung der [C++ / WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt) Visual Studio Extension (VSIX) (bietet projektvorlagenunterstützung sowie C++ / WinRT MSBuild-Eigenschaften und-Ziele) finden Sie unter [Visual Studio-Unterstützung für C++ / WinRT und VSIX](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix).

Dieses Thema stellt vorsorgliche Informationen bereit. Sie sollten diese kennen, auch wenn Sie sie noch nicht sofort brauchen. Die Tabelle mit den Symptomen und Problembehandlungen in unten kann für Sie hilfreich sein, egal ob Sie neuen Code schreiben oder eine bestehende App portieren. Wenn Sie beim Portieren vorankommen möchten, und zu einem Punkt gelangen, an dem Ihr Projekt erstellt und ausgeführt werden kann, dann können Sie temporäre Fortschritte machen, indem Sie jeden nicht essentiellen Code mit Problemen auskommentieren oder streichen. Später können Sie den korrigierten Code wieder einfügen.

Eine Liste mit häufig gestellten Fragen finden Sie [häufig gestellte Fragen](faq.md).

## <a name="tracking-down-xaml-issues"></a>Nachverfolgen von XAML-Problemen
XAML-Analyseausnahmen sind u.U. schwierig zu diagnostizieren, insbesondere wenn keine sinnvollen Fehlermeldungen innerhalb der Ausnahme vorhanden sind. Stellen Sie sicher, dass der Debugger für die Erfassung von Ausnahmen (erste Chance) konfiguriert ist (um die Analyseausnahme möglichst früh zu erfassen). Möglicherweise können Sie die Ausnahmevariable im Debugger überprüfen, um zu ermitteln, ob das HRESULT oder die Meldung hilfreiche Informationen enthält. Überprüfen Sie auch das Visual Studio-Ausgabefenster auf Fehlermeldungen des XAML-Parsers.

Wenn Ihre App beendet wird und Sie nur wissen, dass beim XAML-Markup-Parsing eine unbehandelte Ausnahme ausgelöst wurde, dann könnte das das Ergebnis einer Referenz (per Schlüssel) auf eine fehlende Ressource sein. Es kann sich auch um eine Ausnahme handeln, die innerhalb eines UserControl-Elements, eines benutzerdefinierten Steuerelements oder eines benutzerdefinierten Layoutpanels ausgelöst wurde. Als letzte Möglichkeit kann eine Binärdatei aufgeteilt werden. Entfernen Sie etwa die Hälfte des Markups von einer XAML-Seite, und führen Sie die App erneut aus. So können Sie feststellen, ob sich der Fehler in der entfernten Hälfte (die Sie jetzt in jedem Fall wiederherstellen sollten) oder in der nicht entfernten Hälfte befindet. Wiederholen Sie den Vorgang durch Teilen der Hälfte mit den Fehler solange, Sie das Problem eingegrenzt haben.

## <a name="symptoms-and-remedies"></a>Symptome und Möglichkeiten zur Abhilfe
| Symptom | Abhilfe |
|---------|--------|
| Zur Laufzeit wird eine Ausnahme mit einem HRESULT-Wert von REGDB_E_CLASSNOTREGISTERED ausgelöst. | Eine Ursache für diesen Fehler ist, dass Ihre Komponente für Windows-Runtime nicht geladen werden kann. Stellen Sie sicher, dass die Windows-Runtime-Metadaten-Datei (`.winmd`) der Komponente den gleichen Namen wie die Komponenten-Binärdatei (`.dll`) hat, die auch der Name des Projekts und der Name des Root-Namespaces ist. Stellen Sie außerdem sicher, dass die Windows-Runtime-Metadaten und die Binärdatei vom Build-Prozess korrekt in den `Appx`-Ordner der nutzenden App kopiert wurden. Und stellen Sie sicher, dass die `AppxManifest.xml` der nutzenden App (auch im `Appx`-Ordner) ein **&lt;InProcessServer&gt;**-Element enthält, das die aktivierbare Klasse und den Binärnamen korrekt deklariert. Dieser Fehler kann auch auftreten, wenn Sie den Fehler machen, eine lokal implementierte Laufzeitklasse über den Standardkonstruktor des projizierten Typs zu instanziieren. Siehe [XAML-Steuerelemente; Binden an eine C++/WinRT-Eigenschaft](binding-property.md) für weitere Informationen über die korrekte Verwendung des projizierten Typs in diesem Fall. |
| Der C++ Compiler erzeugt den Fehler „*'implements_type': ist kein Mitglied einer direkten oder indirekten Basisklasse von '&lt;projizierter Typ&gt;'*”. | Dies kann passieren, wenn Sie **make** mit dem nicht im Namespace qualifizierten Namen Ihres Implementierungstyps (z. B. **MyRuntimeClass**) aufrufen und den Header dieses Typs nicht eingebunden haben. Der Compiler interpretiert **MyRuntimeClass** als den projizierten Typ. Die Lösung besteht darin, den Header für Ihren Implementierungstyp (z. B. `MyRuntimeClass.h`) einzubinden. |
| Der C++ Compiler erzeugt den Fehler „*Versuch, eine gelöschte Funktion zu referenzieren*”. | Dies kann passieren, wenn Sie **make** aufrufen und der Implementierungstyp, den Sie als Template-Parameter übergeben, einen `= delete`-Standardkonstruktor hat. Bearbeiten Sie die Header-Datei des Implementierungstyps und ändern Sie `= delete` zu `= default`. Sie können auch einen Konstruktor in die IDL der Laufzeitklasse einfügen. |
| Sie haben [**INotifyPropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged) implementiert, aber Ihre XAML-Bindungen werden nicht aktualisiert (und die Benutzeroberfläche registriert sich nicht für [**PropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged.PropertyChanged)). | Denken Sie daran, `Mode=OneWay` (oder TwoWay) für Ihren Bindungsausdruck im XAML-Markup festzulegen. Weitere Informationen unter [XAML-Steuerelemente; Binden an eine C++/WinRT-Eigenschaft](binding-property.md). |
| Sie binden ein XAML-Items-Steuerelement an eine Observable-Collection, und zur Laufzeit wird eine Ausnahme mit der Meldung „Der Parameter ist falsch” ausgelöst. | Deklarieren Sie in Ihrer IDL und Ihrer Implementierung jede Observable-Collection als den Typ **Windows.Foundation.Collections.IVector<IInspectable>**. Geben Sie jedoch ein Objekt zurück, das **Windows.Foundation.Collections.IObservableVector<T>** implementiert, wobei T Ihr Elementtyp ist. Weitere Informationen unter [XAML-Items-Steuerelemente; Binden an eine C++/WinRT-Collection](binding-collection.md).  |
| Der C++ Compiler erzeugt einen Fehler der Form „*'MyImplementationType_base&lt;MyImplementationType&gt;': kein passender Standardkonstruktor verfügbar*”.|Dies kann passieren, wenn Sie von einem Typ ableiten, der einen nicht-trivialen Konstruktor hat. Der Konstruktor Ihres abgeleiteten Typs muss die Parameter übergeben, die der Konstruktor des Basistyps benötigt. Ein funktionierendes Beispiel finden Sie unter [Abgeleitet von einem Typ, der einen nicht-trivialen Konstruktor hat.](author-apis.md#deriving-from-a-type-that-has-a-non-default-constructor)|
| Der C++ Compiler erzeugt den Fehler „*Konvertierung von 'const std::vector&lt;std::wstring,std::allocator&lt;_Ty&gt;&gt;' zu 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'* nicht möglich”.|Dies kann passieren, wenn Sie eine Std:: Vector des Std::wstring an eine Windows-Runtime-API übergeben, die eine Collection erwartet. Weitere Informationen finden Sie unter [Standard C++ Datentypen und C++/WinRT](std-cpp-data-types.md).|
| Der C++ Compiler erzeugt den Fehler „*Konvertierung von 'const std::vector&lt;winrt::hstring,std::allocator&lt;_Ty&gt;&gt;' zu 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'* nicht möglich”.|Dies kann passieren, wenn Sie ein std::vector von winrt::hstring an eine asynchrone Windows-Runtime-API übergeben, die eine Collection erwartet, und Sie den Vektor weder kopiert noch in den asynchronen Aufrufer verschoben haben. Weitere Informationen finden Sie unter [Standard C++ Datentypen und C++/WinRT](std-cpp-data-types.md).|
| Beim Öffnen eines Projekts erzeugt Visual Studio den Fehler „*Die Anwendung für das Projekt ist nicht installiert.*”.|Falls noch nicht geschehen, müssen Sie **Windows Universal-Tools für die C++ Entwicklung** im Dialogfeld **Neues Projekt** von Visual Studio installieren. Wenn das Problem dadurch nicht behoben wird, hängt das Projekt möglicherweise von der C++/WinRT Visual Studio Extension (VSIX) ab (siehe [Visual Studio-Unterstützung für C++/WinRT und VSIX](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix)).|
| Die Tests des Zertifizierungskit für Windows-Apps erzeugen einen Fehler wie „*Eine Ihrer Laufzeitklassen ist nicht von einer Windows-Basisklasse abgeleitet ist. Alle zusammensetzbaren Klassen müssen letztlich von einem Typ im Windows-Namespace abgeleitet werden”*.|Jeder Laufzeitklasse (, die Sie in Ihrer Anwendung deklarieren), die von einer Basisklasse abgeleitet wird, wird als bezeichnet ein *zusammensetzbaren* Klasse. Die letztendliche Basisklasse einer zusammensetzbaren Klasse muss ein Typ sein, in einem Windows-Namespace sein. Beispiel: [**Windows.UI.Xaml.DependencyObject**](/uwp/api/windows.ui.xaml.dependencyobject). Finden Sie unter [XAML-Steuerelemente; binden an eine C++ / WinRT-Eigenschaft](binding-property.md) Weitere Details.|
| Der C++ Compiler erzeugt einen „*WinRT-Typ erforderlich*”-Fehler für eine EventHandler- oder TypedEventHandler-Delegat-Spezialisierung.|Verwenden Sie stattdessen **winrt::delegate&lt;...T&gt;**. Siehe [Erstellen von Ereignissen mit C++/WinRT](author-events.md).|
| Der C++ Compiler erzeugt einen „*WinRT-Typ erforderlich*”-Fehler für einen asynchron Windows-Runtime-Vorgang-Spezialisierung.|Erwägen Sie stattdessen, einen PPL-[**Task**](https://msdn.microsoft.com/library/hh750113) (Parallel Patterns Library) zurückzugeben. Siehe [Parallelität und asynchrone Vorgänge](concurrency.md).|
| Der C++ Compiler erzeugt „*Fehler C2220: Warnung als Fehler behandelt – keine'Object'-Datei generiert*”.|Korrigieren Sie entweder die Warnung oder Festlegen der **C/C++-**>**Allgemeine**>**Warnungen als Fehler behandeln** , **Nein (/ WX-)**.|
| Ihre App stürzt ab, weil ein Ereignis-Handler in Ihrem C++/WinRT-Objekt aufgerufen wird, nachdem das Objekt zerstört wurde.|Finden Sie [problemlos den Zugriff auf die *dieser* Zeiger mit einem Delegaten für die Ereignisbehandlung](weak-references.md#safely-accessing-the-this-pointer-with-an-event-handling-delegate).|
| Der C++ Compiler generiert „*Fehler C2338: Dies wird nur für schwache Referenzen unterstützt.*”.|Sie fordern eine schwache Referenz für einen Typ an, der die **winrt::no_weak_ref**-Marker-Struktur als Template-Argument an seine Basisklasse übergeben hat. Finden Sie unter [Opt-Out der Unterstützung von schwachen Referenzen](weak-references.md#opting-out-of-weak-reference-support).|
| Der C++ Linker erzeugt "*Fehler LNK2019: nicht aufgelöstes externes Symbol*"|Finden Sie unter [Warum ist der Linker und mir ein "LNK2019: nicht aufgelöstes externes Symbol" Fehler?](faq.md#why-is-the-linker-giving-me-a-lnk2019-unresolved-external-symbol-error).|
| Die toolkette LLVM und Clang erzeugt den Fehler bei Verwendung mit C++ / WinRT.|Wir unterstützen nicht die toolkette LLVM und Clang wird für C++ / WinRT, aber wenn Sie emulieren möchten, wie wir sie intern verwenden und Sie können versuchen ein Experiment wie gemäß dem [kann ich LLVM/Clang zum Kompilieren mit C++ verwenden / WinRT?](faq.md#can-i-use-llvmclang-to-compile-with-cwinrt).|
| Der C++ Compiler erzeugt "*kein passender Standardkonstruktor verfügbar*" für einen projizierten Typ. | Wenn Sie versuchen, zu verzögern, die Initialisierung einer Runtime-Klassenobjekt, oder nutzen und eine Laufzeitklasse im selben Projekt zu implementieren, müssen Sie rufen Sie die `nullptr_t` Konstruktor. Weitere Informationen finden Sie unter [Nutzen von APIs mit C++/WinRT](consume-apis.md). |
| Der C++ Compiler erzeugt "*Fehler C3861: 'From_abi': Bezeichner wurde nicht gefunden*", und andere Fehler mit Ursprung in *base.h*. Dieser Fehler kann angezeigt werden, wenn Sie Visual Studio 2017 verwenden (Version 15.8.0 oder höher), und für das Windows SDK-Version 10.0.17134.0 (Windows 10, Version 1803). | Entweder als Ziel einer späteren (größere Übereinstimmung) Version des Windows SDK oder der Set-Projekteigenschaft **C/C++-** > **Sprache** > **Konformitätsmodus: Nein** (auch, wenn **/ PERMISSIVE--** erscheint in Projekteigenschaft **C/C++-**  >  **Sprache** > **Befehlszeile** unter **Zusätzliche Optionen**, löschen Sie ihn). |
| Der C++ Compiler erzeugt "*Fehler C2039: 'IUnknown': ist kein Mitglied von ' \'global Namespace''*". | Finden Sie unter [wie neu zuweisen, Ihre C++ / WinRT-Projekt auf eine neuere Version des Windows SDK](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk). |
| Der C++ Linker erzeugt "*Fehler LNK2019: nicht aufgelöstes externes Symbol _WINRT_CanUnloadNow@0 verwiesen in Funktion _VSDesignerCanUnloadNow@0 *" | Finden Sie unter [wie neu zuweisen, Ihre C++ / WinRT-Projekt auf eine neuere Version des Windows SDK](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk). |

> [!NOTE]
> Wenn Ihre Frage in diesem Thema nicht beantwortet, unter Umständen Hilfe finden Sie auf der [Visual Studio C++-Entwicklercommunity](https://developercommunity.visualstudio.com/spaces/62/index.html)oder mithilfe der [ `c++-winrt` -Tag auf Stack Overflow](https://stackoverflow.com/questions/tagged/c%2b%2b-winrt).
