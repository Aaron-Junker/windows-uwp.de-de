---
description: Die Tabelle mit den Symptomen und Problembehandlungen in diesem Thema kann für Sie hilfreich sein, egal ob Sie neuen Code schreiben oder eine bestehende App portieren.
title: Problembehandlung bei C++/WinRT-Problemen
ms.date: 04/23/2019
ms.topic: article
keywords: windows 10, uwp, standard, c++, cpp, winrt, projizierung, problembehandlung, HRESULT, fehler
ms.localizationpriority: medium
ms.openlocfilehash: 563545e8a819ab6af5bbc0604c18b4833d76bebb
ms.sourcegitcommit: 1f39b67f2711b96c6b4e7ed7107a9a47127d4e8f
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 06/05/2019
ms.locfileid: "66721674"
---
# <a name="troubleshooting-cwinrt-issues"></a>Problembehandlung bei C++/WinRT-Problemen

> [!NOTE]
> Informationen zum Installieren und Verwenden der [C++ / WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt) finden Sie in Visual Studio-Erweiterung (VSIX) (die projektunterstützung für die Vorlage bereitstellt) [Visual Studio-Unterstützung für C++ / WinRT](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-xaml-the-vsix-extension-and-the-nuget-package).

Dieses Thema stellt vorsorgliche Informationen bereit. Sie sollten diese kennen, auch wenn Sie sie noch nicht sofort brauchen. Die Tabelle mit den Symptomen und Problembehandlungen in unten kann für Sie hilfreich sein, egal ob Sie neuen Code schreiben oder eine bestehende App portieren. Wenn Sie beim Portieren vorankommen möchten, und zu einem Punkt gelangen, an dem Ihr Projekt erstellt und ausgeführt werden kann, dann können Sie temporäre Fortschritte machen, indem Sie jeden nicht essentiellen Code mit Problemen auskommentieren oder streichen. Später können Sie den korrigierten Code wieder einfügen.

Eine Liste der häufig gestellte Fragen, finden Sie unter [häufig gestellte Fragen](faq.md).

## <a name="tracking-down-xaml-issues"></a>Nachverfolgen von XAML-Problemen
XAML-Analyseausnahmen sind u. U. schwierig zu diagnostizieren, insbesondere wenn keine sinnvollen Fehlermeldungen innerhalb der Ausnahme vorhanden sind. Stellen Sie sicher, dass der Debugger für die Erfassung von Ausnahmen (erste Chance) konfiguriert ist (um die Analyseausnahme möglichst früh zu erfassen). Möglicherweise können Sie die Ausnahmevariable im Debugger überprüfen, um zu ermitteln, ob das HRESULT oder die Meldung hilfreiche Informationen enthält. Überprüfen Sie auch das Visual Studio-Ausgabefenster auf Fehlermeldungen des XAML-Parsers.

Wenn Ihre App beendet wird und Sie nur wissen, dass beim XAML-Markup-Parsing eine unbehandelte Ausnahme ausgelöst wurde, dann könnte das das Ergebnis einer Referenz (per Schlüssel) auf eine fehlende Ressource sein. Es kann sich auch um eine Ausnahme handeln, die innerhalb eines UserControl-Elements, eines benutzerdefinierten Steuerelements oder eines benutzerdefinierten Layoutpanels ausgelöst wurde. Als letzte Möglichkeit kann eine Binärdatei aufgeteilt werden. Entfernen Sie etwa die Hälfte des Markups von einer XAML-Seite, und führen Sie die App erneut aus. So können Sie feststellen, ob sich der Fehler in der entfernten Hälfte (die Sie jetzt in jedem Fall wiederherstellen sollten) oder in der nicht entfernten Hälfte befindet. Wiederholen Sie den Vorgang durch Teilen der Hälfte mit den Fehler solange, Sie das Problem eingegrenzt haben.

## <a name="symptoms-and-remedies"></a>Symptome und Möglichkeiten zur Abhilfe
| Symptom | Abhilfe |
|---------|--------|
| Zur Laufzeit wird eine Ausnahme mit einem HRESULT-Wert von REGDB_E_CLASSNOTREGISTERED ausgelöst. | Eine Ursache für diesen Fehler ist, dass Ihre Komponente für Windows-Runtime nicht geladen werden kann. Stellen Sie sicher, dass die Windows-Runtime-Metadaten-Datei (`.winmd`) der Komponente den gleichen Namen wie die Komponenten-Binärdatei (`.dll`) hat, die auch der Name des Projekts und der Name des Root-Namespaces ist. Stellen Sie außerdem sicher, dass die Windows-Runtime-Metadaten und die Binärdatei vom Build-Prozess korrekt in den `Appx`-Ordner der nutzenden App kopiert wurden. Und stellen Sie sicher, dass die `AppxManifest.xml` der nutzenden App (auch im `Appx`-Ordner) ein **&lt;InProcessServer&gt;** -Element enthält, das die aktivierbare Klasse und den Binärnamen korrekt deklariert. Dieser Fehler kann auch auftreten, wenn Sie den Fehler machen, eine lokal implementierte Laufzeitklasse über den Standardkonstruktor des projizierten Typs zu instanziieren. Siehe [XAML-Steuerelemente; Binden an eine C++/WinRT-Eigenschaft](binding-property.md) für weitere Informationen über die korrekte Verwendung des projizierten Typs in diesem Fall. |
| Der C++ Compiler erzeugt den Fehler „ *'implements_type': ist kein Mitglied einer direkten oder indirekten Basisklasse von '&lt;projizierter Typ&gt;'* ”. | Dies kann passieren, wenn Sie **make** mit dem nicht im Namespace qualifizierten Namen Ihres Implementierungstyps (z. B. **MyRuntimeClass**) aufrufen und den Header dieses Typs nicht eingebunden haben. Der Compiler interpretiert **MyRuntimeClass** als den projizierten Typ. Die Lösung besteht darin, den Header für Ihren Implementierungstyp (z. B. `MyRuntimeClass.h`) einzubinden. |
| Der C++ Compiler erzeugt den Fehler „*Versuch, eine gelöschte Funktion zu referenzieren*”. | Dies kann passieren, wenn Sie **make** aufrufen und der Implementierungstyp, den Sie als Template-Parameter übergeben, einen `= delete`-Standardkonstruktor hat. Bearbeiten Sie die Header-Datei des Implementierungstyps und ändern Sie `= delete` zu `= default`. Sie können auch einen Konstruktor in die IDL der Laufzeitklasse einfügen. |
| Sie haben [**INotifyPropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged) implementiert, aber Ihre XAML-Bindungen werden nicht aktualisiert (und die Benutzeroberfläche registriert sich nicht für [**PropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged.PropertyChanged)). | Denken Sie daran, `Mode=OneWay` (oder TwoWay) für Ihren Bindungsausdruck im XAML-Markup festzulegen. Weitere Informationen unter [XAML-Steuerelemente; Binden an eine C++/WinRT-Eigenschaft](binding-property.md). |
| Sie binden ein XAML-Items-Steuerelement an eine Observable-Collection, und zur Laufzeit wird eine Ausnahme mit der Meldung „Der Parameter ist falsch” ausgelöst. | Deklarieren Sie in Ihrer IDL und Ihrer Implementierung jede Observable-Collection als den Typ **Windows.Foundation.Collections.IVector<IInspectable>** . Geben Sie jedoch ein Objekt zurück, das **Windows.Foundation.Collections.IObservableVector<T>** implementiert, wobei T Ihr Elementtyp ist. Weitere Informationen unter [XAML-Items-Steuerelemente; Binden an eine C++/WinRT-Collection](binding-collection.md).  |
| Der C++ Compiler erzeugt einen Fehler der Form „ *'MyImplementationType_base&lt;MyImplementationType&gt;': kein passender Standardkonstruktor verfügbar*”.|Dies kann passieren, wenn Sie von einem Typ ableiten, der einen nicht-trivialen Konstruktor hat. Der Konstruktor Ihres abgeleiteten Typs muss die Parameter übergeben, die der Konstruktor des Basistyps benötigt. Ein funktionierendes Beispiel finden Sie unter [Abgeleitet von einem Typ, der einen nicht-trivialen Konstruktor hat.](author-apis.md#deriving-from-a-type-that-has-a-non-default-constructor)|
| Der C++ Compiler erzeugt den Fehler „*Konvertierung von 'const std::vector&lt;std::wstring,std::allocator&lt;_Ty&gt;&gt;' zu 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'* nicht möglich”.|Dies kann passieren, wenn Sie eine Std:: Vector des Std::wstring an eine Windows-Runtime-API übergeben, die eine Collection erwartet. Weitere Informationen finden Sie unter [Standard C++ Datentypen und C++/WinRT](std-cpp-data-types.md).|
| Der C++ Compiler erzeugt den Fehler „*Konvertierung von 'const std::vector&lt;winrt::hstring,std::allocator&lt;_Ty&gt;&gt;' zu 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'* nicht möglich”.|Dies kann passieren, wenn Sie ein std::vector von winrt::hstring an eine asynchrone Windows-Runtime-API übergeben, die eine Collection erwartet, und Sie den Vektor weder kopiert noch in den asynchronen Aufrufer verschoben haben. Weitere Informationen finden Sie unter [Standard C++ Datentypen und C++/WinRT](std-cpp-data-types.md).|
| Beim Öffnen eines Projekts erzeugt Visual Studio den Fehler „*Die Anwendung für das Projekt ist nicht installiert.* ”.|Falls noch nicht geschehen, müssen Sie **Windows Universal-Tools für die C++ Entwicklung** im Dialogfeld **Neues Projekt** von Visual Studio installieren. Wenn nicht, die das Problem zu beheben, das Projekt hängt von der C++-/ c++ / WinRT Visual Studio-Erweiterung (VSIX) (finden Sie unter [Visual Studio-Unterstützung für C++ / WinRT](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-xaml-the-vsix-extension-and-the-nuget-package).|
| Die Windows-Zertifizierungskit für Apps-Tests, löst einen Fehler an, dass ein von der Runtime-Klassen "*ist nicht von einer Windows-Basisklasse abgeleitet. Alle zusammensetzbare Klassen müssen letztendlich von einem Typ in der Windows-Namespace abgeleitet*".|Common Language Runtime-Klasse (die Sie in Ihrer Anwendung deklarieren), die von einer Basisklasse abgeleitet ist, wird als bezeichnet ein *zusammensetzbar* Klasse. Die ultimative Basisklasse einer zusammensetzbaren Klasse muss einen Typ, die in einem Windows-Namespace stammen; z. B. [ **Windows.UI.Xaml.DependencyObject**](/uwp/api/windows.ui.xaml.dependencyobject). Finden Sie unter [XAML steuert, binden an einen C++ / WinRT-Eigenschaft](binding-property.md) Weitere Details.|
| Der C++ Compiler erzeugt einen „*WinRT-Typ erforderlich*”-Fehler für eine EventHandler- oder TypedEventHandler-Delegat-Spezialisierung.|Verwenden Sie stattdessen **winrt::delegate&lt;...T&gt;** . Siehe [Erstellen von Ereignissen mit C++/WinRT](author-events.md).|
| Der C++ Compiler erzeugt einen „*WinRT-Typ erforderlich*”-Fehler für einen asynchron Windows-Runtime-Vorgang-Spezialisierung.|Erwägen Sie stattdessen, einen PPL-[**Task**](https://docs.microsoft.com/cpp/parallel/concrt/reference/task-class) (Parallel Patterns Library) zurückzugeben. Siehe [Parallelität und asynchrone Vorgänge](concurrency.md).|
| Der C++ Compiler erzeugt „*Fehler C2220: Warnung als Fehler behandelt – keine'Object'-Datei generiert*”.|Korrigieren Sie die Warnung, oder legen Sie **C/C++-**  > **allgemeine** > **Warnungen als Fehler behandeln** zu  **Nein (/ WX-)** .|
| Ihre App stürzt ab, weil ein Ereignis-Handler in Ihrem C++/WinRT-Objekt aufgerufen wird, nachdem das Objekt zerstört wurde.|Finden Sie unter [problemlos den Zugriff auf die *dies* Zeiger durch einen Delegaten zur Verarbeitung von Ereignissen](weak-references.md#safely-accessing-the-this-pointer-with-an-event-handling-delegate).|
| Der C++-Compiler generiert "*Fehler C2338: Dies gilt nur für die Unterstützung der schwache Verweis*".|Sie fordern eine schwache Referenz für einen Typ an, der die **winrt::no_weak_ref**-Marker-Struktur als Template-Argument an seine Basisklasse übergeben hat. Finden Sie unter [Deaktivierung der Unterstützung von schwachen Verweis](weak-references.md#opting-out-of-weak-reference-support).|
| Der C++-Linker generiert "*Fehler LNK2019: Nicht aufgelöstes externes Symbol*"|Finden Sie unter [Warum wird der Linker stellt mir so eine "LNK2019: Nicht aufgelöstes externes Symbol"Fehler? ](faq.md#why-is-the-linker-giving-me-a-lnk2019-unresolved-external-symbol-error).|
| Die LLVM und Clang-toolkette führt zu Fehlern bei der Verwendung mit C++ / WinRT.|Wir unterstützen nicht die LLVM und Clang-toolkette für C++ / WinRT, aber wenn Sie möchten zu emulieren, wie wir es intern verwenden und Sie könnten versuchen ein Experiment, z. B. die in beschrieben [kann ich mit C++ kompilieren LLVM/Clang verwenden / WinRT?](faq.md#can-i-use-llvmclang-to-compile-with-cwinrt).|
| Der C++-Compiler generiert "*kein geeigneter Standardkonstruktor verfügbar*" für einen projizierten Typ. | Wenn Sie verwenden möchten, verzögert die Initialisierung eines Objekts für den Common Language Runtime-Klasse, oder nutzen und eine Runtime-Klasse im gleichen Projekt implementieren, müssen Sie rufen die `nullptr_t` Konstruktor. Weitere Informationen finden Sie unter [Nutzen von APIs mit C++/WinRT](consume-apis.md). |
| Die C++ erzeugt der Compiler "*Fehler C3861 aus:"From_abi": Bezeichner wurde nicht gefunden*", und andere Fehler, die aus *base.h*. Dieser Fehler möglicherweise angezeigt, wenn es sich bei Verwendung von Visual Studio 2017 (Version 15.8.0 oder höher), und auf dem Windows SDK, Version 10.0.17134.0 (Windows 10, Version 1803). | Eine höhere (genauer) abzielen Version des Windows SDK oder Set-Projekteigenschaft **C/C++-**  > **Sprache** > **Konformitätsmodus: Nicht** (auch wenn **/ PERMISSIVE--** wird in den Projekteigenschaften **C/C++-**  > **Sprache** > **über die Befehlszeile**  unter **zusätzliche Optionen**, löschen Sie sie). |
| Der C++-Compiler generiert "*Fehler C2039: "IUnknown": ist kein Mitglied von "\`globalen Namespace''* ". | Finden Sie unter [wie neu ausrichten, Ihrem C + c++ / WinRT-Projekt auf eine neuere Version des Windows SDK](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk). |
| Der C++-Linker generiert "*Fehler LNK2019: nicht aufgelöstes externes Symbol _WINRT_CanUnloadNow@0 verwiesen wird, in der Funktion _VSDesignerCanUnloadNow@0* " | Finden Sie unter [wie neu ausrichten, Ihrem C + c++ / WinRT-Projekt auf eine neuere Version des Windows SDK](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk). |
| Der Buildprozess generiert die Fehlermeldung *die c++ / WinRT VSIX nicht mehr Build-projektunterstützung bereitstellt.  Fügen Sie einen Projektverweis auf die Microsoft.Windows.CppWinRT Nuget-Paket hinzu*. | Installieren Sie die **Microsoft.Windows.CppWinRT** NuGet-Paket in Ihr Projekt. Weitere Informationen finden Sie unter [frühere Versionen der Erweiterung VSIX](intro-to-using-cpp-with-winrt.md#earlier-versions-of-the-vsix-extension). |
| Die C++ Linker generiert *Fehler LNK2019: nicht aufgelöstes externes Symbol*, mit der eine Erwähnung von *Winrt::impl::consume_Windows_Foundation_Collections_IVector*. | Als [ C++WinRT 2.0](news.md#news-and-changes-in-cwinrt-20), wenn Sie eine bereichsbasierte verwenden `for` für eine Windows-Runtime-Sammlung werden jetzt müssen Sie `#include <winrt/Windows.Foundation.Collections.h>`. |

> [!NOTE]
> Wenn in diesem Thema nicht Ihre Fragen beantworten, können Sie Hilfe zu finden, indem Sie die [Visual Studio C++-Entwickler-Community](https://developercommunity.visualstudio.com/spaces/62/index.html), oder mithilfe der [ `c++-winrt` tag in Stack Overflow](https://stackoverflow.com/questions/tagged/c%2b%2b-winrt).
