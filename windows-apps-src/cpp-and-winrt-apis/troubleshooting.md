---
description: Die Tabelle mit den Symptomen und Problembehandlungen in diesem Thema kann für Sie hilfreich sein. Hierbei spielt es keine Rolle, ob Sie neuen Code schreiben oder eine bestehende App portieren.
title: Behandlung von C++/WinRT-Problemen
ms.date: 04/23/2019
ms.topic: article
keywords: Windows 10, uwp, Standard, C++, cpp, winrt, Projektion, Problembehandlung, HRESULT, Fehler
ms.localizationpriority: medium
ms.openlocfilehash: 268792dfe8053feca8c1e6fcb486bede4b26ee6a
ms.sourcegitcommit: 7aaf0740a5d3a17ebf9214aa5e5d056924317673
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 10/21/2020
ms.locfileid: "92297723"
---
# <a name="troubleshooting-cwinrt-issues"></a>Behandlung von C++/WinRT-Problemen

> [!NOTE]
> Informationen zum Installieren und Verwenden der [C++/WinRT](./intro-to-using-cpp-with-winrt.md) Visual Studio-Erweiterung (VSIX) die die Unterstützung für Projektvorlage und den Build bereitstellt) finden Sie unter [Visual Studio-Unterstützung für C++/ WinRT](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-xaml-the-vsix-extension-and-the-nuget-package).

Dieses Thema stellt vorsorglich Informationen zur Verfügung. Sie sollten diese kennen, auch wenn Sie sie noch nicht unmittelbar benötigen. Die Tabelle mit den Symptomen und Lösungen unten kann für Sie hilfreich sein, gleich ob Sie neuen Code schreiben oder eine bestehende Anwendung portieren. Wenn Sie beim Portieren vorankommen und an den Punkt gelangen möchten, an dem Ihr Projekt erstellt und ausgeführt werden kann, können Sie vorübergehend Fortschritte machen, indem Sie allen nicht zwingend erforderlichen Code, der Probleme verursacht, auskommentieren oder streichen. Sie können zu einem späteren Zeitpunkt zurückkehren und Ihren Rückstand abarbeiten.

Eine Liste der häufig gestellten Fragen finden Sie unter [häufig gestellte Fragen](faq.md).

## <a name="tracking-down-xaml-issues"></a>Ermitteln von XAML-Problemen
XAML-Analyseausnahmen sind u.U. schwierig zu diagnostizieren, insbesondere wenn keine aussagekräftigen Fehlermeldungen innerhalb der Ausnahme vorhanden sind. Stellen Sie sicher, dass der Debugger für die Erfassung von Ausnahmen (erste Chance) konfiguriert ist (um die Analyseausnahme möglichst früh zu erfassen). Möglicherweise können Sie die Ausnahmevariable im Debugger überprüfen, um zu ermitteln, ob das HRESULT oder die Meldung hilfreiche Informationen enthält. Überprüfen Sie auch das Visual Studio-Ausgabefenster auf Fehlermeldungen des XAML-Parsers.

Wenn Ihre App beendet wird und Sie nur wissen, dass beim XAML-Markup-Parsing eine unbehandelte Ausnahme ausgelöst wurde, dann könnte das das Ergebnis eines Verweises (anhand des Schlüssels) auf eine fehlende Ressource sein. Es kann sich auch um eine Ausnahme handeln, die innerhalb eines UserControl-Elements, eines benutzerdefinierten Steuerelements oder eines benutzerdefinierten Layoutpanels ausgelöst wurde. Als letzte Möglichkeit kann eine Binärdatei aufgeteilt werden. Entfernen Sie etwa die Hälfte des Markups von einer XAML-Seite, und führen Sie die App erneut aus. So können Sie feststellen, ob sich der Fehler in der entfernten Hälfte (die Sie jetzt in jedem Fall wiederherstellen sollten) oder in der nicht entfernten Hälfte befindet. Wiederholen Sie den Vorgang durch Teilen der Hälfte mit den Fehler solange, Sie das Problem eingegrenzt haben.

## <a name="symptoms-and-remedies"></a>Symptome und Lösungen
| Symptom | Problembehandlung |
|---------|--------|
| Zur Laufzeit wird eine Ausnahme mit dem HRESULT-Wert REGDB_E_CLASSNOTREGISTERED ausgelöst. | Siehe [Warum erhalte ich die Ausnahme „Klasse nicht registriert“?](faq.md#why-am-i-getting-a-class-not-registered-exception). |
| Der C++ Compiler erzeugt den Fehler „*‚implements_type‘: ist kein Mitglied einer direkten oder indirekten Basisklasse von ‚&lt;projizierter Typ&gt;‘*“. | Dies kann passieren, wenn Sie **make** mit dem nicht im Namespace qualifizierten Namen Ihres Implementierungstyps (z.B. **MyRuntimeClass**) aufrufen und den Header dieses Typs nicht eingebunden haben. Der Compiler interpretiert **MyRuntimeClass** als den projizierten Typ. Die Lösung besteht darin, den Header für Ihren Implementierungstyp (z.B. `MyRuntimeClass.h`) einzubinden. |
| Der C++ Compiler erzeugt den Fehler „*Versuch, auf eine gelöschte Funktion zu verweisen*“. | Dies kann passieren, wenn Sie **make** aufrufen und der Implementierungstyp, den Sie als Vorlagenparameter übergeben, einen `= delete`-Standardkonstruktor hat. Bearbeiten Sie die Header-Datei des Implementierungstyps, und ändern Sie `= delete` in `= default`. Sie können auch einen Konstruktor in die IDL für die Laufzeitklasse einfügen. |
| Sie haben [**INotifyPropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged) implementiert, aber Ihre XAML-Bindungen werden nicht aktualisiert (und die Benutzeroberfläche registriert sich nicht für [**PropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged.PropertyChanged)). | Denken Sie daran, `Mode=OneWay` (oder TwoWay) für Ihren Bindungsausdruck im XAML-Markup festzulegen. Weitere Informationen finden Sie unter [XAML-Steuerelemente; Binden an eine C++/WinRT-Eigenschaft](binding-property.md). |
| Sie binden ein XAML-Items-Steuerelement an eine Observable-Sammlung, und zur Laufzeit wird eine Ausnahme mit der Meldung „Der Parameter ist falsch“ ausgelöst. | Deklarieren Sie in Ihrer IDL und Ihrer Implementierung jede Observable-Sammlung als Typ **Windows.Foundation.Collections.IVector<IInspectable>**. Geben Sie jedoch ein Objekt zurück, das **Windows.Foundation.Collections.IObservableVector<T>** implementiert, wobei T Ihr Elementtyp ist. Weitere Informationen finden Sie unter [XAML-Items-Steuerelemente; Binden an eine C++/WinRT-Collection](binding-collection.md).  |
| Der C++ Compiler erzeugt einen Fehler der Form „*‚MyImplementationType_base&lt;MyImplementationType&gt;‘: kein passender Standardkonstruktor verfügbar*“.|Dies kann passieren, wenn Sie von einem Typ abgeleitet haben, der einen nicht-trivialen Konstruktor hat. Der Konstruktor Ihres abgeleiteten Typs muss die Parameter übergeben, die der Konstruktor des Basistyps benötigt. Ein funktionierendes Beispiel finden Sie unter [Ableiten von einem Typ, der einen nicht trivialen Konstruktor hat](author-apis.md#deriving-from-a-type-that-has-a-non-default-constructor).|
| Der C++ Compiler erzeugt den Fehler „*Konvertierung von ‚const std::vector&lt;std::wstring,std::allocator&lt;_Ty&gt;&gt;‘ zu ‚const winrt::param::async_iterable&lt;winrt::hstring&gt; &‘* nicht möglich“.|Dies kann passieren, wenn Sie einen std::vector vom Typ std::wstring an eine Windows Runtime-API übergeben, die eine Sammlung erwartet. Weitere Informationen finden Sie unter [Standard C++-Datentypen und C++/WinRT](std-cpp-data-types.md).|
| Der C++ Compiler erzeugt den Fehler „*Konvertierung von ‚const std::vector&lt;winrt::hstring,std::allocator&lt;_Ty&gt;&gt;‘ zu „const winrt::param::async_iterable&lt;winrt::hstring&gt; &‘* nicht möglich“.|Dies kann passieren, wenn Sie einen std::vector vom Typ winrt::hstring an eine asynchrone Windows Runtime-API übergeben, die eine Sammlung erwartet, und Sie den Vektor zum asynchronen Aufrufer weder kopiert noch verschoben haben. Weitere Informationen finden Sie unter [Standard C++-Datentypen und C++/WinRT](std-cpp-data-types.md).|
| Beim Öffnen eines Projekts erzeugt Visual Studio den Fehler „*Die Anwendung für das Projekt ist nicht installiert*“.|Falls noch nicht geschehen, müssen Sie im Dialogfeld **Neues Projekt** von Visual Studio **Universelle Windows-Tools für die C++-Entwicklung** installieren. Wenn das Problem dadurch nicht behoben wird, hängt das Projekt möglicherweise von der C++/WinRT Visual Studio Extension (VSIX) ab (siehe [Visual Studio-Unterstützung für C++/WinRT](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-xaml-the-vsix-extension-and-the-nuget-package)).|
| Die Tests im Zertifizierungskit für Windows-Apps erzeugen einen Fehler, dass eine Ihrer Laufzeitklassen „*ist nicht von einer Windows-Basisklasse abgeleitet. Alle zusammensetzbaren Klassen müssen letztlich von einem Typ im Windows-Namespace abgeleitet sein*“.|Jede Laufzeitklasse (die Sie in Ihrer Anwendung deklarieren), die von einer Basisklasse abgeleitet ist, wird als *zusammensetzbare* Klasse bezeichnet. Die letztliche Basisklasse einer zusammensetzbaren Klasse muss ein Typ sein, der seinen Ursprung in einem Windows.*-Namespace hat; beispielsweise [**Windows.UI.Xaml.DependencyObject**](/uwp/api/windows.ui.xaml.dependencyobject). Weitere Details finden Sie unter [XAML-Steuerelemente; Binden an eine C++/WinRT-Eigenschaft](binding-property.md).|
| Der C++-Compiler erzeugt einen Fehler, der darauf hinweist, dass *T ein WinRT-Typ sein muss*, für eine EventHandler- oder TypedEventHandler-Delegatspezialisierung.|Erwägen Sie stattdessen die Verwendung von **winrt::delegate&lt;...T&gt;**. Mehr dazu erfahren Sie unter [Erstellen von Ereignissen in C++/WinRT](author-events.md).|
| Der C++-Compiler erzeugt einen Fehler, der darauf hinweist, dass *T ein WinRT-Typ sein muss*, für eine Spezialisierung eines asynchronen Vorgangs von Windows-Runtime.|Erwägen Sie, stattdessen eine [**Aufgabe**](/cpp/parallel/concrt/reference/task-class) der Parallel Patterns Library (PPL) zurückzugeben. Mehr dazu erfahren Sie unter [Parallelität und asynchrone Vorgänge](concurrency.md).|
| Der C++ Compiler erzeugt einen Fehler, der darauf hinweist, dass *T ein WinRT-Typ sein muss*, wenn Sie [**winrt::xaml_typename**](/uwp/cpp-ref-for-winrt/xaml-typename) aufrufen.|Verwenden Sie den projizierten Typ mit **winrt::xaml_typename** (z. B. **BgLabelControlApp::BgLabelControl**), und nicht den Implementierungstyp (z. B. nicht **BgLabelControlApp::implementation::BgLabelControl**). Siehe [XAML-Steuerelemente, benutzerdefinierte Vorlagen](xaml-cust-ctrl.md).|
| Der C++ Compiler erzeugt „*Fehler C2220: Warnung als Fehler behandelt – keine ‚Object‘-Datei generiert*“.|Korrigiere entweder die Warnung, oder lege **C/C++**  > **Allgemein** > **Warnung als Fehler behandeln** auf **Nein (/WX-)** fest.|
| Ihre App stürzt ab, weil ein Ereignishandler in Ihrem C++/WinRT-Objekt aufgerufen wird, nachdem das Objekt zerstört wurde.|Weitere Informationen dazu finden Sie unter [Sicherer Zugriff auf den *this*-Zeiger mit einer Stellvertretung zum Ereignishandling](weak-references.md#safely-accessing-the-this-pointer-with-an-event-handling-delegate)|
| Der C++-Compiler erzeugt „*Fehler C2338: Dies dient nur zur Unterstützung schwacher Verweise*“.|Sie fordern einen schwachen Verweis für einen Typ an, der die **winrt::no_weak_ref**-Markerstruktur als Vorlagenargument an seine Basisklasse übergeben hat. Mehr dazu finden Sie unter [Verzicht auf die Unterstützung von schwachen Verweisen](weak-references.md#opting-out-of-weak-reference-support).|
| Der C++-Linker erzeugt „*Fehler LNK2019: Nicht aufgelöstes externes Symbol*“|Mehr dazu finden Sie unter [Warum erhalte ich den Fehler „LNK2019: Nicht aufgelöstes externes Symbol“ vom Linker?](faq.md#why-is-the-linker-giving-me-a-lnk2019-unresolved-external-symbol-error).|
| Die LLVM- und Clang-Toolkette führt bei der Verwendung mit C++/WinRT zu Fehlern.|Wir unterstützen die LLVM- und Clang-Toolkette für C++/WinRT nicht, aber wenn Sie die interne Verwendung durch uns emulieren wollten, können Sie ein Experiment wie das in [Kann ich LLVM/Clang für die Kompilierung mit C++/WinRT verwenden?](faq.md#can-i-use-llvmclang-to-compile-with-cwinrt) beschriebene ausprobieren.|
| Der C++-Compiler erzeugt „*kein passender Standardkonstruktor verfügbar*“ für einen projizierten Typ. | Wenn Sie versuchen, die Initialisierung eines Laufzeitklassenobjekts zu verzögern, oder eine Laufzeitklasse im gleichen Projekt zu nutzen und zu implementieren, müssen Sie den **std::nullptr_t**-Konstruktor aufrufen. Weitere Informationen finden Sie unter [Nutzen von APIs mit C++/WinRT](consume-apis.md). |
| Der C++-Compiler erzeugt „*Fehler C3861: ‚from_abi‘: Bezeichner nicht gefunden*“ und andere Fehler, die aus *base.h* stammen. Möglicherweise sehen Sie diesen Fehler, wenn Sie Visual Studio 2017 (Version 15.8.0 oder höher) verwenden und die Windows SDK-Version 10.0.17134.0 (Windows 10, Version 1803) als Ziel festgelegt haben. | Verwenden Sie für das Projekt entweder eine höhere (konformere) Version des Windows SDK oder die Projekteigenschaft **C/C++**  > **Sprache** > **Konformitätsmodus: Nein** (auch wenn **/permissive-** in der Projekteigenschaft **C/C++**  > **Sprache** > **Befehlszeile** unter **Zusätzliche Optionen** angezeigt wird. Löschen Sie es dann). |
| Der C++-Compiler erzeugt „*Fehler C2039: ‚IUnknown‘: ist kein Mitglied von ‚\`global namespace‘* “. | Lesen Sie [So richten Sie Ihr C++/WinRT-Projekt auf eine höhere Version des Windows SDK neu aus](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk). |
| Der C++-Linker erzeugt „*Fehler LNK2019: nicht aufgelöstes Symbol _WINRT_CanUnloadNow@0 mit Verweis in Funktion _VSDesignerCanUnloadNow@0*“ | Lesen Sie [So richten Sie Ihr C++/WinRT-Projekt auf eine höhere Version des Windows SDK neu aus](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk). |
| Der Buildprozess erzeugt die Fehlermeldung *Die C++/WinRT-VSIX stellt keine Buildunterstützung für das Projekt mehr zur Verfügung.  Fügen Sie dem Projekt einen Verweis auf das Microsoft.Windows.CppWinRT-Nuget-Paket hinzu*. | Installieren Sie das NuGet-Paket **Microsoft.Windows.CppWinRT** für Ihr Projekt. Ausführlichere Informationen finden Sie unter [Frühere Versionen der VSIX-Erweiterung](intro-to-using-cpp-with-winrt.md#earlier-versions-of-the-vsix-extension). |
| Der C++-Linker erzeugt *Fehler LNK2019: nicht aufgelöstes externes Symbol* mit einer Erwähnung von *winrt::impl::consume_Windows_Foundation_Collections_IVector*. | Wenn Sie seit [C++/WinRT 2.0](news.md#news-and-changes-in-cwinrt-20) ein bereichsbasiertes `for` in einer Windows Runtime-Sammlung verwenden, müssen Sie jetzt `#include <winrt/Windows.Foundation.Collections.h>` ausführen. |
| Der C++-Compiler erzeugt „*Fehler C4002: Zu viele Argumente für den Aufruf des funktionsähnlichen Makros "GetCurrentTime*“. | Siehe [Wie löse ich Mehrdeutigkeiten bei „GetCurrentTime“ und/oder „TRY“ auf?](faq.md#how-do-i-resolve-ambiguities-with-getcurrenttime-andor-try). |
| Der C++-Compiler erzeugt „*Fehler C2334: Unerwartete(s) Token vor "{"; sichtbarer Funktionstext wird übersprungen*“. | Siehe [Wie löse ich Mehrdeutigkeiten bei „GetCurrentTime“ und/oder „TRY“ auf?](faq.md#how-do-i-resolve-ambiguities-with-getcurrenttime-andor-try). |
| Der C++-Compiler erzeugt „*winrt::impl::produce&lt;D,I&gt;: Instanz von abstrakter Klasse kann nicht erstellt werden, da "GetBindingConnector" nicht vorhanden ist*“. | Sie müssen `#include <winrt/Windows.UI.Xaml.Markup.h>` hinzufügen. |
| Der C++-Compiler erzeugt „*Fehler C2039: "promise_type" ist kein Member von "std::experimental::coroutine_traits<void>"*“. | Die Coroutine muss ein Objekt eines asynchronen Vorgangs oder **winrt::fire_and_forget** zurückgeben. Mehr dazu erfahren Sie unter [Parallelität und asynchrone Vorgänge](concurrency.md). |
| Im Projekt wird „*Mehrdeutiger Zugriff von"PopulatePropertyInfoOverride"*“ ausgelöst. | Dieser Fehler kann auftreten, wenn Sie eine Basisklasse in der IDL und eine andere Basisklasse im XAML-Markup deklarieren. |
| Beim ersten Laden einer C++/WinRT-Projektmappe wird „*Fehler beim Entwurfszeitbuild für das Projekt "MyProject.vcxproj", Konfiguration "Debug\|x 86". IntelliSense ist möglicherweise nicht verfügbar.* “ ausgegeben. | Dieses IntelliSense-Problem ist nach dem ersten Buildvorgang nicht mehr vorhanden. |
| Wenn beim Registrieren eines Delegaten [**winrt::auto_revoke**](/uwp/cpp-ref-for-winrt/auto-revoke-t) angegeben wird, wird die Ausnahme [**winrt::hresult_no_interface**](/uwp/cpp-ref-for-winrt/error-handling/hresult-no-interface) erzeugt. | Siehe [Wenn das Registrieren des Delegaten fehlschlägt](handle-events.md#if-your-auto-revoke-delegate-fails-to-register). |
|Wenn in einer C++/WinRT-App eine [C#-Komponente für Windows-Runtime](../winrt-components/creating-windows-runtime-components-in-csharp-and-visual-basic.md), die XAML verwendet, verarbeitet wird, erzeugt der Compiler einen Fehler der Form „ *'MyNamespace_XamlTypeInfo': is not a member of 'winrt::MyNamespace'* “, wobei *MyNamespace* der Name des Namespace der Windows Runtime-Komponente ist. | Fügen Sie in `pch.h` in der verarbeitenden C++/WinRT-App `#include <winrt/MyNamespace.MyNamespace_XamlTypeInfo.h>` hinzu, und ersetzen Sie *MyNamespace* entsprechend. |

> [!NOTE]
> Wenn Ihre Frage in diesem Thema nicht beantwortet wurde, finden Sie möglicherweise Hilfe in der [Visual Studio C++-Entwicklercommunity](https://developercommunity.visualstudio.com/spaces/62/index.html), oder verwenden Sie das [`c++-winrt`-Tag auf Stack Overflow](https://stackoverflow.com/questions/tagged/c%2b%2b-winrt).