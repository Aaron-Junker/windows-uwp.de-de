---
author: stevewhims
description: Die Tabelle mit den Symptomen und Problembehandlungen in diesem Thema kann für Sie hilfreich sein, egal ob Sie neuen Code schreiben oder eine bestehende App portieren.
title: Problembehandlung bei C++/WinRT-Problemen
ms.author: stwhi
ms.date: 04/10/2018
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: windows 10, uwp, standard, c++, cpp, winrt, projizierung, problembehandlung, HRESULT, fehler
ms.localizationpriority: medium
ms.openlocfilehash: 21f5fc4773979b2d7940b85871264e27d56d29c4
ms.sourcegitcommit: ab92c3e0dd294a36e7f65cf82522ec621699db87
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 05/03/2018
ms.locfileid: "1832264"
---
# <a name="troubleshooting-cwinrtwindowsuwpcpp-and-winrt-apisintro-to-using-cpp-with-winrt-issues"></a>Problembehandlung bei [C++/WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt)-Problemen
> [!NOTE]
> **Einige Informationen beziehen sich auf die Vorabversion, die vor der kommerziellen Freigabe möglicherweise wesentlichen Änderungen unterliegt. Microsoft übernimmt keine Garantie, weder ausdrücklich noch stillschweigend, für die hier bereitgestellten Informationen.**

> [!NOTE]
> Informationen über die aktuelle Verfügbarkeit der C++/WinRT Visual Studio Extension (VSIX) (die Projektvorlagenunterstützung sowie C++/WinRT MSBuild-Eigenschaften und -Ziele bietet) finden Sie unter [Visual Studio-Unterstützung für C++/WinRT und VSIX](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix).

Dieses Thema stellt vorsorgliche Informationen bereit. Sie sollten diese kennen, auch wenn Sie sie noch nicht sofort brauchen. Die Tabelle mit den Symptomen und Problembehandlungen in unten kann für Sie hilfreich sein, egal ob Sie neuen Code schreiben oder eine bestehende App portieren. Wenn Sie beim Portieren vorankommen möchten, und zu einem Punkt gelangen, an dem Ihr Projekt erstellt und ausgeführt werden kann, dann können Sie temporäre Fortschritte machen, indem Sie jeden nicht essentiellen Code mit Problemen auskommentieren oder streichen. Später können Sie den korrigierten Code wieder einfügen.

## <a name="tracking-down-xaml-issues"></a>Nachverfolgen von XAML-Problemen
XAML-Analyseausnahmen sind u.U. schwierig zu diagnostizieren, insbesondere wenn keine sinnvollen Fehlermeldungen innerhalb der Ausnahme vorhanden sind. Stellen Sie sicher, dass der Debugger für die Erfassung von Ausnahmen (erste Chance) konfiguriert ist (um die Analyseausnahme möglichst früh zu erfassen). Möglicherweise können Sie die Ausnahmevariable im Debugger überprüfen, um zu ermitteln, ob das HRESULT oder die Meldung hilfreiche Informationen enthält. Überprüfen Sie auch das Visual Studio-Ausgabefenster auf Fehlermeldungen des XAML-Parsers.

Wenn Ihre App beendet wird und Sie nur wissen, dass beim XAML-Markup-Parsing eine unbehandelte Ausnahme ausgelöst wurde, dann könnte das das Ergebnis einer Referenz (per Schlüssel) auf eine fehlende Ressource sein. Es kann sich auch um eine Ausnahme handeln, die innerhalb eines UserControl-Elements, eines benutzerdefinierten Steuerelements oder eines benutzerdefinierten Layoutpanels ausgelöst wurde. Als letzte Möglichkeit kann eine Binärdatei aufgeteilt werden. Entfernen Sie etwa die Hälfte des Markups von einer XAML-Seite, und führen Sie die App erneut aus. So können Sie feststellen, ob sich der Fehler in der entfernten Hälfte (die Sie jetzt in jedem Fall wiederherstellen sollten) oder in der nicht entfernten Hälfte befindet. Wiederholen Sie den Vorgang durch Teilen der Hälfte mit den Fehler solange, Sie das Problem eingegrenzt haben.

## <a name="symptoms-and-remedies"></a>Symptome und Möglichkeiten zur Abhilfe
| Symptom | Abhilfe |
|---------|--------|
| Zur Laufzeit wird eine Ausnahme mit einem HRESULT-Wert von REGDB_E_CLASSNOTREGISTERED ausgelöst. | Eine Ursache für diesen Fehler ist, dass Ihre Komponente für Windows-Runtime nicht geladen werden kann. Stellen Sie sicher, dass die Windows-Runtime-Metadaten-Datei (`.winmd`) der Komponente den gleichen Namen wie die Komponenten-Binärdatei (`.dll`) hat, die auch der Name des Projekts und der Name des Root-Namespaces ist. Stellen Sie außerdem sicher, dass die Windows-Runtime-Metadaten und die Binärdatei vom Build-Prozess korrekt in den `Appx`-Ordner der nutzenden App kopiert wurden. Und stellen Sie sicher, dass die `AppxManifest.xml` der nutzenden App (auch im `Appx`-Ordner) ein **&lt;InProcessServer&gt;**-Element enthält, das die aktivierbare Klasse und den Binärnamen korrekt deklariert. Dieser Fehler kann auch auftreten, wenn Sie den Fehler machen, eine lokal implementierte Laufzeitklasse über den Standardkonstruktor des projizierten Typs zu instanziieren. Siehe [XAML-Steuerelemente; Binden an eine C++/WinRT-Eigenschaft](binding-property.md) für weitere Informationen über die korrekte Verwendung des projizierten Typs in diesem Fall. |
| Der C++ Compiler erzeugt den Fehler „*'implements_type': ist kein Mitglied einer direkten oder indirekten Basisklasse von '&lt;projizierter Typ&gt;'*”. | Dies kann passieren, wenn Sie **make** mit dem nicht im Namespace qualifizierten Namen Ihres Implementierungstyps (z. B. **MyRuntimeClass**) aufrufen und den Header dieses Typs nicht eingebunden haben. Der Compiler interpretiert **MyRuntimeClass** als den projizierten Typ. Die Lösung besteht darin, den Header für Ihren Implementierungstyp (z. B. `MyRuntimeClass.h`) einzubinden. |
| Der C++ Compiler erzeugt den Fehler „*Versuch, eine gelöschte Funktion zu referenzieren*”. | Dies kann passieren, wenn Sie **make** aufrufen und der Implementierungstyp, den Sie als Template-Parameter übergeben, einen `= delete`-Standardkonstruktor hat. Bearbeiten Sie die Header-Datei des Implementierungstyps und ändern Sie `= delete` zu `= default`. Sie können auch einen Konstruktor in die IDL der Laufzeitklasse einfügen. |
| Sie haben [**INotifyPropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged) implementiert, aber Ihre XAML-Bindungen werden nicht aktualisiert (und die Benutzeroberfläche registriert sich nicht für [**PropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged.PropertyChanged)). | Denken Sie daran, `Mode=OneWay` (oder TwoWay) für Ihren Bindungsausdruck im XAML-Markup festzulegen. Weitere Informationen unter [XAML-Steuerelemente; Binden an eine C++/WinRT-Eigenschaft](binding-property.md). |
| Sie binden ein XAML-Items-Steuerelement an eine Observable-Collection, und zur Laufzeit wird eine Ausnahme mit der Meldung „Der Parameter ist falsch” ausgelöst. | Deklarieren Sie in Ihrer IDL und Ihrer Implementierung jede Observable-Collection als den Typ **Windows.Foundation.Collections.IVector<IInspectable>**. Geben Sie jedoch ein Objekt zurück, das **Windows.Foundation.Collections.IObservableVector<T>** implementiert, wobei T Ihr Elementtyp ist. Weitere Informationen unter [XAML-Items-Steuerelemente; Binden an eine C++/WinRT-Collection](binding-collection.md).  |
| Der C++ Compiler erzeugt einen Fehler der Form „*'MyImplementationType_base&lt;MyImplementationType&gt;': kein passender Standardkonstruktor verfügbar*”.|Dies kann passieren, wenn Sie von einem Typ ableiten, der einen nicht-trivialen Konstruktor hat. Der Konstruktor Ihres abgeleiteten Typs muss die Parameter übergeben, die der Konstruktor des Basistyps benötigt. Ein funktionierendes Beispiel finden Sie unter [Abgeleitet von einem Typ, der einen nicht-trivialen Konstruktor hat.](author-apis.md#deriving-from-a-type-that-has-a-non-trivial-constructor)|
| Der C++ Compiler erzeugt den Fehler „*Konvertierung von 'const std::vector&lt;std::wstring,std::allocator&lt;_Ty&gt;&gt;' zu 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'* nicht möglich”.|Dies kann passieren, wenn Sie eine Std:: Vector des Std::wstring an eine Windows-Runtime-API übergeben, die eine Collection erwartet. Weitere Informationen finden Sie unter [Standard C++ Datentypen und C++/WinRT](std-cpp-data-types.md).|
| Der C++ Compiler erzeugt den Fehler „*Konvertierung von 'const std::vector&lt;winrt::hstring,std::allocator&lt;_Ty&gt;&gt;' zu 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'* nicht möglich”.|Dies kann passieren, wenn Sie ein std::vector von winrt::hstring an eine asynchrone Windows-Runtime-API übergeben, die eine Collection erwartet, und Sie den Vektor weder kopiert noch in den asynchronen Aufrufer verschoben haben. Weitere Informationen finden Sie unter [Standard C++ Datentypen und C++/WinRT](std-cpp-data-types.md).|
| Beim Öffnen eines Projekts erzeugt Visual Studio den Fehler „*Die Anwendung für das Projekt ist nicht installiert.*”.|Falls noch nicht geschehen, müssen Sie **Windows Universal-Tools für die C++ Entwicklung** im Dialogfeld **Neues Projekt** von Visual Studio installieren. Wenn das Problem dadurch nicht behoben wird, hängt das Projekt möglicherweise von der C++/WinRT Visual Studio Extension (VSIX) ab (siehe [Visual Studio-Unterstützung für C++/WinRT und VSIX](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix)).|
| Die Tests des Zertifizierungskit für Windows-Apps erzeugen einen Fehler wie „*Eine Ihrer Laufzeitklassen ist nicht von einer Windows-Basisklasse abgeleitet ist. Alle zusammensetzbaren Klassen müssen letztlich von einem Typ im Windows-Namespace abgeleitet werden”*.|Die letztendliche Basisklasse jeder in der *Anwendung deklarierten Laufzeitklasse* muss ein Typ sein, der aus einem Windows.*-Namespace stammt. Sie können ein Ansichtsmodell aus [**Windows.UI.Xaml.DependencyObject**](/uwp/api/windows.ui.xaml.dependencyobject) ableiten. Alternativ können Sie eine von **DependencyObject** abgeleitete bindbare Basisklasse deklarieren und daraus Ihre Ansichtsmodelle ableiten.|
| Der C++ Compiler erzeugt einen „*WinRT-Typ erforderlich*”-Fehler für eine EventHandler- oder TypedEventHandler-Delegat-Spezialisierung.|Verwenden Sie stattdessen **winrt::delegate&lt;...T&gt;**. Siehe [Erstellen von Ereignissen mit C++/WinRT](author-events.md).|
| Der C++ Compiler erzeugt einen „*WinRT-Typ erforderlich*”-Fehler für einen asynchron Windows-Runtime-Vorgang-Spezialisierung.|Erwägen Sie stattdessen, einen PPL-[**Task**](https://msdn.microsoft.com/library/hh750113) (Parallel Patterns Library) zurückzugeben. Siehe [Parallelität und asynchrone Vorgänge](concurrency.md).|
| Der C++ Compiler erzeugt „*Fehler C2220: Warnung als Fehler behandelt – keine'Object'-Datei generiert*”.|Korrigieren Sie entweder die Warnung oder setzen Sie **C/C++** > **Allgemein** > **Warnung als Fehler behandeln** auf **Nein (/WX-)**.|
| Ihre App stürzt ab, weil ein Ereignis-Handler in Ihrem C++/WinRT-Objekt aufgerufen wird, nachdem das Objekt zerstört wurde.|Siehe [Verwendung des *this*-Objekts in einem Ereignis-Handler](handle-events.md#using-the-this-object-in-an-event-handler).|
| Der C++ Compiler generiert „*Fehler C2338: Dies wird nur für schwache Referenzen unterstützt.*”.|Sie fordern eine schwache Referenz für einen Typ an, der die **winrt::no_weak_ref**-Marker-Struktur als Template-Argument an seine Basisklasse übergeben hat. Siehe [Opt-out der Unterstützung von schwachen Referenzn](weak-references.md#opting-out-of-weak-reference-support).|
| Der C++ Linker erzeugt „*Fehler LNK2019: Nicht aufgelöstes externes Symbol*” für eine API aus den Windows-Namespace-Headern für die C++/WinRT-Projektion (im winrt-Namespace).|Die API wird in einem eingebundenen Header forward-deklariert, aber ihre Definition befindet sich in einem noch nicht eingebundenen Header. Binden Sie den Header ein, der für den Namespace der API benannt ist, und führen Sie eine erneute Erstellung durch.|
