---
description: Die Tabelle mit den Symptomen und Problembehandlungen in diesem Thema kann für Sie hilfreich sein. Hierbei spielt es keine Rolle, ob Sie neuen Code schreiben oder eine bestehende App portieren.
title: Behandlung von C++/WinRT-Problemen
ms.date: 04/23/2019
ms.topic: article
keywords: Windows 10, uwp, Standard, C++, cpp, winrt, Projektion, Problembehandlung, HRESULT, Fehler
ms.localizationpriority: medium
ms.openlocfilehash: 563545e8a819ab6af5bbc0604c18b4833d76bebb
ms.sourcegitcommit: aaa4b898da5869c064097739cf3dc74c29474691
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 06/13/2019
ms.locfileid: "66721674"
---
# <a name="troubleshooting-cwinrt-issues"></a>Behandlung von C++/WinRT-Problemen

> [!NOTE]
> Informationen zum Installieren und Verwenden der [C++/WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt) Visual Studio-Erweiterung (VSIX) die die Unterstützung für Projektvorlage und den Build bereitstellt) finden Sie unter [Visual Studio-Unterstützung für C++/ WinRT](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-xaml-the-vsix-extension-and-the-nuget-package).

Dieses Thema stellt vorsorglich Informationen zur Verfügung. Sie sollten diese kennen, auch wenn Sie sie noch nicht unmittelbar benötigen. Die Tabelle mit den Symptomen und Lösungen unten kann für Sie hilfreich sein, gleich ob Sie neuen Code schreiben oder eine bestehende Anwendung portieren. Wenn Sie beim Portieren vorankommen und an den Punkt gelangen möchten, an dem Ihr Projekt erstellt und ausgeführt werden kann, können Sie vorübergehend Fortschritte machen, indem Sie allen nicht zwingend erforderlichen Code, der Probleme verursacht, auskommentieren oder streichen. Sie können zu einem späteren Zeitpunkt zurückkehren und Ihren Rückstand abarbeiten.

Eine Liste der häufig gestellten Fragen finden Sie unter [häufig gestellte Fragen](faq.md).

## <a name="tracking-down-xaml-issues"></a>Ermitteln von XAML-Problemen
XAML-Analyseausnahmen sind u.U. schwierig zu diagnostizieren, insbesondere wenn keine aussagekräftigen Fehlermeldungen innerhalb der Ausnahme vorhanden sind. Stellen Sie sicher, dass der Debugger für die Erfassung von Ausnahmen (erste Chance) konfiguriert ist (um die Analyseausnahme möglichst früh zu erfassen). Möglicherweise können Sie die Ausnahmevariable im Debugger überprüfen, um zu ermitteln, ob das HRESULT oder die Meldung hilfreiche Informationen enthält. Überprüfen Sie auch das Visual Studio-Ausgabefenster auf Fehlermeldungen des XAML-Parsers.

Wenn Ihre App beendet wird und Sie nur wissen, dass beim XAML-Markup-Parsing eine unbehandelte Ausnahme ausgelöst wurde, dann könnte das das Ergebnis eines Verweises (anhand des Schlüssels) auf eine fehlende Ressource sein. Es kann sich auch um eine Ausnahme handeln, die innerhalb eines UserControl-Elements, eines benutzerdefinierten Steuerelements oder eines benutzerdefinierten Layoutpanels ausgelöst wurde. Als letzte Möglichkeit kann eine Binärdatei aufgeteilt werden. Entfernen Sie etwa die Hälfte des Markups von einer XAML-Seite, und führen Sie die App erneut aus. So können Sie feststellen, ob sich der Fehler in der entfernten Hälfte (die Sie jetzt in jedem Fall wiederherstellen sollten) oder in der nicht entfernten Hälfte befindet. Wiederholen Sie den Vorgang durch Teilen der Hälfte mit den Fehler solange, Sie das Problem eingegrenzt haben.

## <a name="symptoms-and-remedies"></a>Symptome und Lösungen
| Symptom | Abhilfe |
|---------|--------|
| Zur Laufzeit wird eine Ausnahme mit dem HRESULT-Wert REGDB_E_CLASSNOTREGISTERED ausgelöst. | Eine Ursache für diesen Fehler ist, dass Ihre Windows Runtime-Komponente nicht geladen werden kann. Stellen Sie sicher, dass die Windows Runtime-Metadatendatei (`.winmd`) der Komponente den gleichen Namen wie die Komponentenbinärdatei (`.dll`) hat, der auch der Name des Projekts und des Namespacestamms ist. Stellen Sie außerdem sicher, dass die Windows Runtime-Metadaten und die Binärdatei vom Build-Prozess korrekt in den `Appx`-Ordner der nutzenden App kopiert wurden. Und überprüfen Sie, ob das `AppxManifest.xml` der nutzenden App (auch im Ordner `Appx`) ein **&lt;InProcessServer&gt;** -Element enthält, in dem die aktivierbare Klasse und der Binärname ordnungsgemäß deklariert sind. Dieser Fehler kann auch auftreten, wenn Sie den Fehler machen, eine lokal implementierte Laufzeitklasse über den Standardkonstruktor des projizierten Typs zu instanziieren. Weitere Informationen zur ordnungsgemäßen Verwendung des projizierten Typs in diesem Fall finden Sie unter [XAML-Steuerelemente; Binden an eine C++/WinRT-Eigenschaft](binding-property.md). |
| Der C++ Compiler erzeugt den Fehler „ *‚implements_type‘: ist kein Mitglied einer direkten oder indirekten Basisklasse von ‚&lt;projizierter Typ&gt;‘* “. | Dies kann passieren, wenn Sie **make** mit dem nicht im Namespace qualifizierten Namen Ihres Implementierungstyps (z.B. **MyRuntimeClass**) aufrufen und den Header dieses Typs nicht eingebunden haben. Der Compiler interpretiert **MyRuntimeClass** als den projizierten Typ. Die Lösung besteht darin, den Header für Ihren Implementierungstyp (z.B. `MyRuntimeClass.h`) einzubinden. |
| Der C++ Compiler erzeugt den Fehler „*Versuch, auf eine gelöschte Funktion zu verweisen*“. | Dies kann passieren, wenn Sie **make** aufrufen und der Implementierungstyp, den Sie als Vorlagenparameter übergeben, einen `= delete`-Standardkonstruktor hat. Bearbeiten Sie die Header-Datei des Implementierungstyps, und ändern Sie `= delete` in `= default`. Sie können auch einen Konstruktor in die IDL für die Laufzeitklasse einfügen. |
| Sie haben [**INotifyPropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged) implementiert, aber Ihre XAML-Bindungen werden nicht aktualisiert (und die Benutzeroberfläche registriert sich nicht für [**PropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged.PropertyChanged)). | Denken Sie daran, `Mode=OneWay` (oder TwoWay) für Ihren Bindungsausdruck im XAML-Markup festzulegen. Weitere Informationen finden Sie unter [XAML-Steuerelemente; Binden an eine C++/WinRT-Eigenschaft](binding-property.md). |
| Sie binden ein XAML-Items-Steuerelement an eine Observable-Sammlung, und zur Laufzeit wird eine Ausnahme mit der Meldung „Der Parameter ist falsch“ ausgelöst. | Deklarieren Sie in Ihrer IDL und Ihrer Implementierung jede Observable-Sammlung als Typ **Windows.Foundation.Collections.IVector<IInspectable>** . Geben Sie jedoch ein Objekt zurück, das **Windows.Foundation.Collections.IObservableVector<T>** implementiert, wobei T Ihr Elementtyp ist. Weitere Informationen finden Sie unter [XAML-Items-Steuerelemente; Binden an eine C++/WinRT-Collection](binding-collection.md).  |
| Der C++ Compiler erzeugt einen Fehler der Form „ *‚MyImplementationType_base&lt;MyImplementationType&gt;‘: kein passender Standardkonstruktor verfügbar*“.|Dies kann passieren, wenn Sie von einem Typ abgeleitet haben, der einen nicht-trivialen Konstruktor hat. Der Konstruktor Ihres abgeleiteten Typs muss die Parameter übergeben, die der Konstruktor des Basistyps benötigt. Ein funktionierendes Beispiel finden Sie unter [Ableiten von einem Typ, der einen nicht trivialen Konstruktor hat](author-apis.md#deriving-from-a-type-that-has-a-non-default-constructor).|
| Der C++ Compiler erzeugt den Fehler „*Konvertierung von ‚const std::vector&lt;std::wstring,std::allocator&lt;_Ty&gt;&gt;‘ zu ‚const winrt::param::async_iterable&lt;winrt::hstring&gt; &‘* nicht möglich“.|Dies kann passieren, wenn Sie einen std::vector vom Typ std::wstring an eine Windows Runtime-API übergeben, die eine Sammlung erwartet. Weitere Informationen finden Sie unter [Standard C++-Datentypen und C++/WinRT](std-cpp-data-types.md).|
| Der C++ Compiler erzeugt den Fehler „*Konvertierung von ‚const std::vector&lt;winrt::hstring,std::allocator&lt;_Ty&gt;&gt;‘ zu „const winrt::param::async_iterable&lt;winrt::hstring&gt; &‘* nicht möglich“.|Dies kann passieren, wenn Sie einen std::vector vom Typ winrt::hstring an eine asynchrone Windows Runtime-API übergeben, die eine Sammlung erwartet, und Sie den Vektor zum asynchronen Aufrufer weder kopiert noch verschoben haben. Weitere Informationen finden Sie unter [Standard C++-Datentypen und C++/WinRT](std-cpp-data-types.md).|
| Beim Öffnen eines Projekts erzeugt Visual Studio den Fehler „*Die Anwendung für das Projekt ist nicht installiert*“.|Falls noch nicht geschehen, müssen Sie im Dialogfeld **Neues Projekt** von Visual Studio **Universelle Windows-Tools für die C++-Entwicklung** installieren. Wenn das Problem dadurch nicht behoben wird, hängt das Projekt möglicherweise von der C++/WinRT Visual Studio Extension (VSIX) ab (siehe [Visual Studio-Unterstützung für C++/WinRT](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-xaml-the-vsix-extension-and-the-nuget-package)).|
| Die Tests im Zertifizierungskit für Windows-Apps erzeugen einen Fehler, dass eine Ihrer Laufzeitklassen „*ist nicht von einer Windows-Basisklasse abgeleitet. Alle zusammensetzbaren Klassen müssen letztlich von einem Typ im Windows-Namespace abgeleitet sein*“.|Jede Laufzeitklasse (die Sie in Ihrer Anwendung deklarieren), die von einer Basisklasse abgeleitet ist, wird als *zusammensetzbare* Klasse bezeichnet. Die letztliche Basisklasse einer zusammensetzbaren Klasse muss ein Typ sein, der seinen Ursprung in einem Windows.*-Namespace hat; beispielsweise [**Windows.UI.Xaml.DependencyObject**](/uwp/api/windows.ui.xaml.dependencyobject). Weitere Details finden Sie unter [XAML-Steuerelemente; Binden an eine C++/WinRT-Eigenschaft](binding-property.md).|
| Der C++ Compiler erzeugt einen „*WinRT-Typ erforderlich*“-Fehler für eine Stellvertretungsspezialisierung eines EventHandlers oder TypedEventHandlers.|Erwägen Sie stattdessen die Verwendung von **winrt::delegate&lt;...T&gt;** . Mehr dazu erfahren Sie unter [Erstellen von Ereignissen in C++/WinRT](author-events.md).|
| Der C++-Compiler erzeugt einen Fehler „*WinRT-Tp erforderlich*“ für die Spezialisierung eines asynchronen Vorgangs der Windows Runtime.|Erwägen Sie, stattdessen eine [**Aufgabe**](https://docs.microsoft.com/cpp/parallel/concrt/reference/task-class) der Parallel Patterns Library (PPL) zurückzugeben. Mehr dazu erfahren Sie unter [Parallelität und asynchrone Vorgänge](concurrency.md).|
| Der C++ Compiler erzeugt „*Fehler C2220: Warnung als Fehler behandelt – keine ‚Object‘-Datei generiert*“.|Korrigieren Sie entweder die Warnung, oder legen Sie **C/C++**  > **Allgemein** > **Warnung als Fehler behandeln** auf **Nein (/WX-)** fest.|
| Ihre App stürzt ab, weil ein Ereignishandler in Ihrem C++/WinRT-Objekt aufgerufen wird, nachdem das Objekt zerstört wurde.|Weitere Informationen dazu finden Sie unter [Sicherer Zugriff auf den *this*-Zeiger mit einer Stellvertretung zum Ereignishandling](weak-references.md#safely-accessing-the-this-pointer-with-an-event-handling-delegate)|
| Der C++-Compiler erzeugt „*Fehler C2338: Dies dient nur zur Unterstützung schwacher Verweise*“.|Sie fordern einen schwachen Verweis für einen Typ an, der die **winrt::no_weak_ref**-Markerstruktur als Vorlagenargument an seine Basisklasse übergeben hat. Mehr dazu finden Sie unter [Verzicht auf die Unterstützung von schwachen Verweisen](weak-references.md#opting-out-of-weak-reference-support).|
| Der C++-Linker erzeugt „*Fehler LNK2019: Nicht aufgelöstes externes Symbol*“|Mehr dazu finden Sie unter [Warum erhalte ich den Fehler „LNK2019: Nicht aufgelöstes externes Symbol“ vom Linker?](faq.md#why-is-the-linker-giving-me-a-lnk2019-unresolved-external-symbol-error).|
| Die LLVM- und Clang-Toolkette führt bei der Verwendung mit C++/WinRT zu Fehlern.|Wir unterstützen die LLVM- und Clang-Toolkette für C++/WinRT nicht, aber wenn Sie die interne Verwendung durch uns emulieren wollten, können Sie ein Experiment wie das in [Kann ich LLVM/Clang für die Kompilierung mit C++/WinRT verwenden?](faq.md#can-i-use-llvmclang-to-compile-with-cwinrt) beschriebene ausprobieren.|
| Der C++-Compiler erzeugt „*kein passender Standardkonstruktor verfügbar*“ für einen projizierten Typ. | Wenn Sie versuchen, die Initialisierung eines Objekts der Runtime-Klasse zu verzögern, oder eine Runtime-Klasse im gleichen Projekt zu nutzen und zu implementieren, müssen Sie den `nullptr_t`-Konstruktor aufrufen. Weitere Informationen finden Sie unter [Nutzen von APIs mit C++/WinRT](consume-apis.md). |
| Der C++-Compiler erzeugt „*Fehler C3861: ‚from_abi‘: Bezeichner nicht gefunden*“ und andere Fehler, die aus *base.h* stammen. Möglicherweise sehen Sie diesen Fehler, wenn Sie Visual Studio 2017 (Version 15.8.0 oder höher) verwenden und die Windows SDK-Version 10.0.17134.0 (Windows 10, Version 1803) als Ziel festgelegt haben. | Verwenden Sie für das Projekt entweder eine höhere (konformere) Version des Windows SDK oder die Projekteigenschaft **C/C++**  > **Sprache** > **Konformitätsmodus: Nein** (auch wenn **/permissive-** in der Projekteigenschaft **C/C++**  > **Sprache** > **Befehlszeile** unter **Zusätzliche Optionen** angezeigt wird. Löschen Sie es dann). |
| Der C++-Compiler erzeugt „*Fehler C2039: ‚IUnknown‘: ist kein Mitglied von ‚\`global namespace‘* “. | Lesen Sie [So richten Sie Ihr C++/WinRT-Projekt auf eine höhere Version des Windows SDK neu aus](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk). |
| Der C++-Linker erzeugt „*Fehler LNK2019: nicht aufgelöstes Symbol _WINRT_CanUnloadNow@0 mit Verweis in Funktion _VSDesignerCanUnloadNow@0* “ | Lesen Sie [So richten Sie Ihr C++/WinRT-Projekt auf eine höhere Version des Windows SDK neu aus](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk). |
| Der Buildprozess erzeugt die Fehlermeldung *Die C++/WinRT-VSIX stellt keine Buildunterstützung für das Projekt mehr zur Verfügung.  Fügen Sie dem Projekt einen Verweis auf das Microsoft.Windows.CppWinRT-Nuget-Paket hinzu*. | Installieren Sie das NuGet-Paket **Microsoft.Windows.CppWinRT** für Ihr Projekt. Ausführlichere Informationen finden Sie unter [Frühere Versionen der VSIX-Erweiterung](intro-to-using-cpp-with-winrt.md#earlier-versions-of-the-vsix-extension). |
| Der C++-Linker erzeugt *Fehler LNK2019: nicht aufgelöstes externes Symbol* mit einer Erwähnung von *winrt::impl::consume_Windows_Foundation_Collections_IVector*. | Wenn Sie seit [C++/WinRT 2.0](news.md#news-and-changes-in-cwinrt-20) ein bereichsbasiertes `for` in einer Windows Runtime-Sammlung verwenden, müssen Sie jetzt `#include <winrt/Windows.Foundation.Collections.h>` ausführen. |

> [!NOTE]
> Wenn Ihre Frage in diesem Thema nicht beantwortet wurde, finden Sie möglicherweise Hilfe in der [Visual Studio C++-Entwicklercommunity](https://developercommunity.visualstudio.com/spaces/62/index.html), oder verwenden Sie das [`c++-winrt`-Tag auf Stack Overflow](https://stackoverflow.com/questions/tagged/c%2b%2b-winrt).
