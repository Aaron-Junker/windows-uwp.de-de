---
Description: Windows 10 Build 10240 und Updates für Entwicklungstools stellen weiterhin Tools, Features und Umgebungen bereit, die von der universellen Windows-Plattform unterstützt werden.
title: Neuigkeiten in Windows 10, Build 10240 – Juli 2015
keywords: Neuigkeiten, Neuerungen, Aktualisierung, Updates, Features, neu, Windows 10, 1507, 10240
ms.date: 11/02/2017
ms.topic: article
ms.assetid: 4853e55b-2232-4589-903a-ccb60e07aeb8
ms.localizationpriority: medium
ms.openlocfilehash: 28eb1dfecf9f6648bd43606c541daf7b57960771
ms.sourcegitcommit: 6f32604876ed480e8238c86101366a8d106c7d4e
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 06/21/2019
ms.locfileid: "67320445"
---
# <a name="whats-new-in-windows10-for-developers-build-10240"></a>Neuigkeiten für Entwickler in Windows 10, Build 10240

Windows 10, Build 10240, und das aktualisierte SDK stellen Tools, Features und Umgebungen zur Verfügung, mit denen bemerkenswerte Apps für die universelle Windows-Plattform ermöglicht werden. Nach der [Installation der Tools und des SDKs](https://go.microsoft.com/fwlink/?LinkId=821431) unter Windows 10 können Sie entweder [eine neue universelle Windows-App erstellen](../get-started/create-uwp-apps.md) oder lesen, wie Sie Ihren [vorhandenen App-Code unter Windows verwenden](../porting/index.md) können.

Im Folgenden finden Sie einen nach Feature geordneten Überblick über die Neuerungen in Windows 10, Build 10240 (auch bezeichnet als Windows 10, Version 1507).

## <a name="adaptive-layouts"></a>Adaptive Layouts

Feature | Beschreibung
 :---- | ----:
Mehrere Ansichten für maßgeschneiderte Inhalte | XAML bietet neue Unterstützung für die Definition von maßgeschneiderten Ansichten (XAML-Dateien), die eine gemeinsame Codedatei verwenden. Dies erleichtert Ihnen das Erstellen und Verwalten verschiedener Ansichten, die auf eine bestimmte Gerätefamilie oder ein Szenario zugeschnitten sind. Erstellen Sie mehrere Ansichten, wenn Ihre App eine Benutzeroberfläche mit unterschiedlichem Inhalt, Layout oder Navigationsmodellen enthält, die sich für verschiedene Szenarien erheblich unterscheiden. Beispielsweise können Sie für Ihre mobile App ein [Pivot](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Pivot)-Steuerelement mit einer für einhändige Nutzung optimierten Navigation verwenden, für Ihre Desktop-App aber ein [SplitView](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.SplitView)-Steuerelement mit einem für die Maus optimierten Navigationsmenü.
StateTriggers | Mit dem neuen Feature [VisualState.StateTriggers](https://docs.microsoft.com/uwp/api/windows.ui.xaml.visualstate.statetriggers) können Sie Eigenschaften basierend auf der Höhe/Breite des Fensters oder basierend auf einem benutzerdefinierten Auslöser bedingt festlegen. Bisher mussten Sie [SizeChanged](https://docs.microsoft.com/uwp/api/windows.ui.xaml.window.sizechanged)-Windows-Ereignisse im Code behandeln und [VisualStateManager.GotoState](https://docs.microsoft.com/uwp/api/windows.ui.xaml.visualstatemanager.gotostate) aufrufen.
Setter | Mit der neuen [VisualState.Setters](https://docs.microsoft.com/uwp/api/windows.ui.xaml.visualstate.setters)-Syntax können Sie ein vereinfachtes Markup zum Definieren von Eigenschaftsänderungen in [VisualStateManager](https://docs.microsoft.com/uwp/api/windows.ui.xaml.visualstatemanager) verwenden. Bisher mussten Sie ein Storyboard verwenden und Animationen erstellen, um Eigenschaftsänderungen anzuwenden, z. B. das Ändern der Ausrichtung eines [StackPanel](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.stackpanel) von horizontal in vertikal. In universellen Windows-Apps können Sie diese einfachere Setter-Syntax verwenden: <setter target="stackPanel1.Orientation" value="Vertical" />


## <a name="xaml-features"></a>XAML-Features

Feature | Beschreibung
 :---- | :----
Kompilierte Datenbindungen (x:Bind) | In universellen Windows-Apps können Sie den neuen compilerbasierten Bindungsmechanismus verwenden, der durch die Eigenschaft „x:Bind“ aktiviert wird. Compilerbasierte Bindungen werden stark typisiert und zur Kompilierzeit verarbeitet, was schneller ist und Kompilierzeitfehler meldet, wenn Bindungstypen nicht übereinstimmen. Da Bindungen in kompilierten App-Code übersetzt werden, können Sie jetzt Bindungen debuggen, indem Sie den Code in Visual Studio durchlaufen, um bestimmte Bindungsprobleme zu diagnostizieren. Sie können zum Binden an eine Methode „x:Bind“ auch wie folgt verwenden: <textblock text="{x:Bind Customer.Address.ToString()}" /> Für typische Bindungsszenarien können Sie „x:Bind“ anstelle von „Binding“ verwenden und dadurch die Leistung und Verwaltbarkeit verbessern.
Deklaratives inkrementelles Rendering von Listen (x:Phase) | Mit dem neuen Attribut „x:Phase“ können Sie in universellen Windows-Apps inkrementelles Rendering oder Phasenrendering von Listen mit XAML anstelle von Code durchführen. Beim Verschieben von langen Listen mit komplexen Elementen ist Ihre App beim Rendern möglicherweise nicht schnell genug, um mit der Geschwindigkeit der Verschiebung mithalten zu können, was möglicherweise ein schlechtes Benutzererlebnis zur Folge hat. Bei Phasen-Rendering können Sie die Rendering-Priorität einzelner Elemente in einem Listenelement festlegen, damit in schnellen Rendering-Szenarios nur die wichtigsten Teile des Listenelements gerendert werden. Dies führt zu einem reibungsloseren Verschiebungserlebnis für den Benutzer. <br /><br /> In Windows 8.1 könnten Sie Das Ereignis [ContainerContentChanging](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.containercontentchanging) behandeln und Code zum Rendern der Listenelemente in mehreren Phasen schreiben. In UWP-Apps können Sie Phasenrendering erreichen, indem Sie das x:Phase-Attribut deklarativ verwenden. In Verbindung mit kompilierten Bindungen mit X:Bind können Sie mit x:Phase einfach eine Rendering-Priorität für jedes gebundene Element eine Datenvorlage festlegen. Beim Verschieben basiert die Arbeit für das Rendern von Elementen auf phasenbasierten Zeitscheiben, was inkrementelles Rendern von Elementen ermöglicht.
Verzögertes Laden von Benutzeroberflächenelementen (x:deferLoadstrategy) | In Universellen Windows-Apps können Sie mithilfe der neuen Anweisung „x:deferLoadstrategy“ angeben, dass Teile der Benutzeroberfläche verzögert geladen werden. Dies verbessert die Startleistung und verringert die Speichernutzung Ihrer App. Wenn auf Ihrer App-Benutzeroberfläche beispielsweise ein Element für die Datenvalidierung nur bei der Eingabe falscher Daten angezeigt wird, können Sie das Laden dieses Elements verzögern, bis es benötigt wird. Die Elementobjekte werden dann nicht beim Laden der Seite erstellt, sondern erst, wenn ein Datenfehler vorliegt und sie der visuellen Struktur der Seite hinzugefügt werden müssen.
SplitView | Das neue [SplitView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.splitview)-Steuerelement ist eine einfache Möglichkeit zum Ein- und Ausblenden vorübergehend angezeigter Inhalte. Es wird häufig für Navigationsszenarien auf oberster Ebene wie dem „Hamburger-Menü“ verwendet, in denen der Navigationsinhalt ausgeblendet ist, und bei Bedarf durch eine Benutzeraktion eingeblendet wird.
RelativePanel | [RelativePanel](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.relativepanel) ist ein neues Layoutpanel, in dem Sie untergeordnete Objekte relativ zueinander oder relativ zum übergeordneten Panel positionieren und ausrichten können. Beispielsweise können Sie angeben, dass Text immer auf der linken Seite des Panels positioniert und dass eine Schaltfläche immer unterhalb des Texts ausgerichtet werden soll. Verwenden Sie „RelativePanel“ beim Erstellen von Benutzeroberflächen ohne ein klares lineares Muster, das ein [StackPanel](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.stackpanel)- oder [Grid](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.grid)-Steuerelement erfordert.
CalendarView | Das [CalendarView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.calendarview)-Steuerelement vereinfacht das Anzeigen und Auswählen von Datumsangaben und Datumsbereichen mithilfe einer anpassbaren, monatlichen Ansicht. CalendarView unterstützt Features wie Minimum-, Maximum- und Ausfalldaten als Eingrenzung dafür, welche Daten ausgewählt werden können. Sie können auch benutzerdefinierte Belegungsdichtebalken festlegen, die zum Anzeigen der allgemeinen „Belegung“ des Zeitplans an einem bestimmten Tag verwendet werden können.
CalendarDatePicker | [CalendarDatePicker](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.calendardatepicker) ist ein Dropdownsteuerelement, das für die Auswahl eines einzelnen Datums aus einer Kalenderansicht optimiert ist, in der kontextbezogene Informationen wie der Wochentag oder die Belegung des Kalenders von Bedeutung sind. Es ähnelt dem [DatePicker](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.datepicker)-Steuerelement, „DatePicker“ ist jedoch für die Auswahl eines bekannten Datums optimiert, z. B. eines Geburtsdatums.
MediaTransportControls | Die neue [MediaTransportControls](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediatransportcontrols)-Klasse erleichtert das Anpassen der Transportsteuerelemente eines [MediaElement](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaelement). In Windows 8.1 konnten Sie in MediaElement integrierte Transportsteuerelemente aktivieren oder Ihre eigenen Steuerelemente erstellen, die MediaElement-Methoden aufrufen. Jetzt können Sie die integrierte Funktionalität von „MediaTransportControls“ verwenden und das Erscheinungsbild trotzdem problemlos an Ihre App anpassen.
Benachrichtigungen über Eigenschaftsänderungen | In universellen Windows-Apps können Sie auf Eigenschaftsänderungen von „DependencyObjects“ lauschen, und zwar auch für Eigenschaften, die über keine entsprechenden Änderungsereignisse verfügen. Die Benachrichtigung funktioniert wie ein Ereignis, wird aber als Rückruf eingeblendet. Der Rückruf verwendet ein Absenderargument wie einen Ereignishandler, aber verwendet kein Ereignisargument. Stattdessen wird nur der Eigenschaftenbezeichner weitergeleitet, um die Eigenschaft anzugeben. Mit diesen Informationen kann von Ihrer App ein einzelner Handler für mehrere Eigenschaftsbenachrichtigungen definiert werden. Weitere Informationen finden Sie unter [RegisterPropertyChangedCallback](https://docs.microsoft.com/uwp/api/windows.ui.xaml.dependencyobject.registerpropertychangedcallback) sowie unter [UnregisterPropertyChangedCallback](https://docs.microsoft.com/uwp/api/windows.ui.xaml.dependencyobject.unregisterpropertychangedcallback).
Karten | Die [MapControl](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.maps.mapcontrol)-Klasse wurde aktualisiert, um 3D-Luftaufnahmen und Straßenansichten bereitzustellen. Diese neuen Features und die früheren Kartenfunktionen sind jetzt für universelle Windows-Apps verfügbar. Fügen Sie Ihrer App Kartenfunktionen mit den folgenden APIs hinzu: [Windows.UI.Xaml.Controls.Maps](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.maps) und [Windows.Services.Maps](https://docs.microsoft.com/uwp/api/windows.services.maps). Fordern Sie im [Bing Karten Developer Center](https://www.bingmapsportal.com/) einen Schlüssel an, um diese APIs schon heute in einer universellen Windows-App zu nutzen. Weitere Infos finden Sie unter [So wird’s gemacht: Authentifizieren einer Karten-App](https://docs.microsoft.com/previous-versions/windows/apps/dn741528(v=win.10)). Eine weitere Neuheit für Windows 10 besteht darin, dass PC- und Smartphone-Benutzer über die Einstellungs-App Offlinekarten herunterladen können. Wenn sie verfügbar sind, werden Offlinekarten vom [MapControl](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.maps.mapcontrol)-Element zum Anzeigen von Karten genutzt, falls kein Internetzugriff vorhanden ist.
Zuordnung für Eingabeschaltfläche | Die [Windows.UI.Xaml.Input.KeyEventArgs](https://docs.microsoft.com/uwp/api/windows.ui.xaml.input.keyroutedeventargs)-Klasse enthält eine neue [OriginalKey](https://docs.microsoft.com/uwp/api/windows.ui.xaml.input.keyroutedeventargs.originalkey)-Eigenschaft, die es Ihnen in Verbindung mit einer entsprechenden Aktualisierung von [Windows.System.VirtualKey](https://docs.microsoft.com/uwp/api/windows.system.virtualkey) ermöglicht, die ursprüngliche, nicht zugeordnete Eingabeschaltfläche abzurufen, die mit dem Tastatureingabeereignis verknüpft ist.
Freihandeingaben | Dank des [InkCanvas](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.inkcanvas)-Steuerelements und der zugrunde liegenden [InkPresenter](https://docs.microsoft.com/uwp/api/windows.ui.input.inking.inkpresenter)-Klassen ist es jetzt einfacher, die stabile Freihandfunktion in Windows-Runtime-Apps mit C++, C# oder Visual Basic zu verwenden. Das [InkCanvas](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.inkcanvas)-Steuerelement definiert einen Überlagerungsbereich zum Zeichnen und Rendern letzter Striche. Die Funktionen dieses Steuerelements (Eingabe, Verarbeitung und Rendering) basieren auf den Klassen [InkPresenter](https://docs.microsoft.com/uwp/api/windows.ui.input.inking.inkpresenter), [InkStroke](https://docs.microsoft.com/uwp/api/windows.ui.input.inking.inkstroke), [InkRecognizers](https://docs.microsoft.com/uwp/api/windows.ui.input.inking.inkrecognizer) und [InkSynchronizer](https://docs.microsoft.com/uwp/api/windows.ui.input.inking.inksynchronizer). **Wichtig:** Diese Klassen werden in Windows-Apps mit JavaScript nicht unterstützt.


## <a name="updated-xaml-features"></a>Aktualisierte XAML-Features

Feature | Beschreibung
 :---- | :----
CommandBar- und AppBar-Updates | Die Steuerelemente [CommandBar](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.commandbar) und [AppBar](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.appbar) wurden aktualisiert, um über alle Gerätefamilien hinweg eine konsistente API sowie ein konsistentes Verhalten und Benutzererlebnis für UWP-Apps zu gewährleisten. <br /><br />Das Steuerelement „CommandBar“ für universelle Windows-Apps wurde verbessert, um eine Obermenge an AppBar-Funktionen und mehr Flexibilität bei den Verwendungsmöglichkeiten in Ihrer App bereitzustellen. Es wird empfohlen, „CommandBar“ für alle neuen universellen Windows-Apps unter Windows 10 zu verwenden. In einem CommandBar-Element unter Windows 8.1 konnten nur Steuerelemente mit [ICommandBarElement](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.icommandbarelement) verwendet werden (beispielsweise [AppBarButton](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.appbarbutton)). In universellen Windows-Apps können Sie jetzt benutzerdefinierte Inhalte neben AppBarButtons auch in CommandBar einfügen. <br /><br />Das Steuerelement „AppBar“ wurde aktualisiert, damit Sie Ihre Windows 8.1-Apps, die AppBar für die universelle Windows-Plattform verwenden, auf einfache Weise verschieben können. AppBar wurde zur Verwendung mit Vollbild-Apps entwickelt und wird mithilfe von Bewegungen am Bildschirmrand aufgerufen. Durch Steuerelementupdates werden Probleme in Windows 10 behoben, z. B. bei Apps im Fenstermodus und wenn keine Wischbewegungen vom Bildschirmrand aus unterstützt werden. <br /><br />Der [ausgeblendete AppBar.ClosedDisplayMode](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.appbar.closeddisplaymode), der zuvor nur auf Windows Phone vorhanden war, wird jetzt auf allen Gerätefamilien unterstützt und lässt Ihnen die Wahl zwischen verschiedenen Hinweisebenen für Befehle. AppBar zeigt standardmäßig einen Mini-Hinweis an, der für Konsistenz sorgt, wenn Sie Windows 8.1-Apps auf universelle Windows-Apps aktualisieren und sich nicht mehr auf die Unterstützung von Gesten am Bildschirmrand verlassen können.
GridView-Updates | Vor Windows 10 war das GridView-Layout unter Windows standardmäßig horizontal und unter Windows Phone standardmäßig vertikal ausgerichtet. In UWP-Apps verwendet GridView standardmäßig ein vertikales Layout für alle Gerätefamilien, um zu gewährleisten, dass Sie über eine konsistente Standardoberfläche verfügen.
AreStickyGroupHeadersEnabled-Eigenschaft | Wenn Sie gruppierte Daten in [ListView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listview) oder [GridView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.gridview) anzeigen, bleiben die Gruppenköpfe jetzt sichtbar, wenn ein Listenbildlauf durchgeführt wird. Dies ist wichtig bei großen Datensätzen, bei denen der Kopf den Kontakt für die Daten zur Verfügung stellt, die dem Benutzer angezeigt werden. In Fällen, in denen jedoch nur wenige Elemente in jeder Gruppe enthalten sind, möchten Sie vielleicht, dass die Köpfe beim Bildlauf mit den Elementen aus dem Bildschirm hinausbewegt werden. Sie können die AreStickyGroupHeadersEnabled-Eigenschaft in [ItemsStackPanel](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.itemsstackpanel) und [ItemsWrapGrid](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.itemswrapgrid) festlegen, um dieses Verhalten zu steuern.
GroupHeaderContainerFromItemContainer-Methode | Wenn Sie gruppierte Daten in einem [ItemsControl](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.itemscontrol) anzeigen, können Sie die [GroupHeaderContainerFromItemContainer](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.itemscontrol.groupheadercontainerfromitemcontainer)-Methode aufrufen, um einen Verweis auf den übergeordneten Header für die Gruppe abzurufen. Wenn beispielsweise ein Benutzer das letzte Element in einer Gruppe löscht, können Sie einen Verweis auf den Gruppenkopf abrufen und den Artikel und den Gruppenkopf zusammen entfernen.
ChoosingGroupHeaderContainer-Ereignis | Mit dem neuen Ereignis [ChoosingGroupHeaderContainer](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.choosinggroupheadercontainer) auf [ListViewBase](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase) können Sie den Zustand für die Gruppenköpfe in einer ListView oder GridView festlegen. Beispielsweise möchten Sie dieses Ereignis so handhaben, dass [AutomationProperties.Nameproperty](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.automationproperties.nameproperty) auf den Gruppenkopf zum Darstellen der Gruppe in Hilfstechnologien festgelegt wird.
ChoosingItemContainer-Ereignis | Durch das neue Ereignis [ChoosingItemContainer](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.choosingitemcontainer) auf ListViewBase erhalten Sie eine bessere Kontrolle über die Virtualisierung der Benutzeroberfläche in einem [ListView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listview) oder [GridView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.gridview). Verwenden Sie dieses Ereignis in Verbindung mit dem Ereignis [ContainerContentChanging](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.containercontentchanging), um Ihre eigene Warteschlange mit wiederverwerteten Containern zu verwalten, auf die Sie bei Bedarf zugreifen. Wenn z. B. die Datenquelle durch einen Filter zurückgesetzt wurde, können Sie schnell einen bereits erstellten Satz von visuellen Elementen (ItemContainers) mit ihren Daten anpassen, um optimale Leistung zu erzielen.
Virtualisierung des Listenbildlaufs |Die XAML-Steuerelemente [ListView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listview) und [GridView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.gridview) besitzen ein neues Ereignis [ListViewBase.ChooseingItemContainer](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.choosingitemcontainer), das die Leistung des Steuerelements verbessert, wenn eine Änderung in der Datensammlung erfolgt. Anstatt die Liste vollständig zurückzusetzen, wobei die Eingangsanimation erneut wiedergegeben wird, behält das System jetzt die derzeit in der Ansicht befindlichen Elemente sowie den Fokus und den Auswahlstatus. Neue und entfernte Artikel im Viewport werden problemlos in die Animation eingebunden bzw. ausgeblendet. Nach einer Änderung in der Datensammlung, in der Container nicht zerstört werden, kann eine App alle „alten“ Elemente schnell mit dem vorhergehenden Container abgleichen und die Weiterverarbeitung von Aufhebungsmethoden für den Behälterlebenszyklus überspringen. Es werden nur „neue“ Elemente verarbeitet und den wiederverwendeten oder neuen Containern zugeordnet.
SelectRange-Methode und SelectedRanges-Eigenschaft | In universellen Windows-Apps ermöglichen die Steuerelemente [ListView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listview) und [GridView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.gridview) jetzt die Auswahl von Elementen anhand von Elementindexbereichen anstelle von Elementobjektverweisen. Dies ist eine effizientere Möglichkeit, um die Auswahl von Elementen zu beschreiben, da Elementobjekte nicht für alle ausgewählten Elemente erstellt werden müssen. Weitere Informationen finden Sie unter [ListViewBase.SelectedRanges](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.selectedranges), [ListViewBase.SelectRange](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.selectrange), und [ListViewBase.DeselectRange](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.deselectrange).
Neue ListViewItemPresenter-APIs | [ListView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listview) und [GridView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.gridview) verwenden Elementreferenten, die die standardmäßigen visuellen Elemente für Auswahl und Fokus bereitstellen. In UWP-Apps verfügen [ListViewItemPresenter](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.primitives.listviewitempresenter) und [GridViewItemPresenter](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.primitives.gridviewitempresenter) über neue Eigenschaften, mit denen Sie die visuellen Objekte für Listenelemente weiter anpassen können. Die neuen Eigenschaften sind „CheckBoxBrush“, „CheckMode“, „FocusSecondaryBorderBrush“, „PointerOverForeground“, „PressedBackground“ und „SelectedPressedBackground“.
SemanticZoom-Updates | Das [SemanticZoom](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.semanticzoom)-Steuerelement hat jetzt auf allen Gerätefamilien ein einheitliches Verhalten für UWP-Apps. Die Standardaktion zum Wechseln zwischen der vergrößerten Ansicht und der verkleinerten Ansicht ist, auf einen Gruppenkopf in der vergrößerten Ansicht zu tippen. Dies entspricht dem Verhalten für Windows Phone 8.1, unterscheidet sich jedoch von Windows 8.1, welches zum Zoomen die Zusammendrückbewegung verwendet. Zum Ändern der Ansichten bei Verwendung der Zusammendrückbewegung für das Zoomen legen Sie den internen ScrollViewer von SemanticZoom auf [ScrollViewer.ZoomMode](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.scrollviewer.zoommode)="Enabled" auf fest. <br /><br />Für universelle Windows-Apps ersetzt die verkleinerte Ansicht die vergrößerte Ansicht und weist die gleiche Größe auf wie die ersetzte Ansicht. Dies entspricht dem Verhalten unter Windows 8.1, unterscheidet sich jedoch von Windows Phone 8.1, bei dem die verkleinerte Ansicht die volle Größe des Bildschirms belegte und über allen anderen Inhalten gerendert wurde.
DatePicker- und TimePicker-Updates | Die Steuerelemente [DatePicker](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.datepicker) und [TimePicker](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.timepicker) verfügen jetzt in allen Gerätefamilien über eine konsistente Implementierung für universelle Windows-Apps. Sie besitzen auch ein neues Erscheinungsbild für Windows 10. Der Popupteil des Steuerelements verwendet nun auf allen Geräten die Steuerelemente [DatePickerFlyout](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.datepickerflyout) und [TimePickerFlyout](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.timepickerflyout). Dies entspricht dem Verhalten für Windows Phone 8.1, unterscheidet sich jedoch vom Betriebssystem Windows 8.1, in dem [ComboBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.combobox)-Steuerelemente verwendet wurden. Mit den Flyout-Steuerelementen können Sie ganz einfach eine benutzerdefinierte Datums- und Uhrzeitauswahl erstellen.
Neue APIs für ScrollViewer | [ScrollViewer](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.scrollviewer) verfügt über neue Ereignisse vom Typ [DirectManipulationStarted](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.scrollviewer.directmanipulationstarted) und [DirectManipulationCompleted](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.scrollviewer.directmanipulationcompleted), die die App über den Start und das Ende von Verschiebungen per Toucheingabe benachrichtigen. Sie können diese Ereignisse behandeln, um Ihre Benutzeroberfläche mit diesen Benutzeraktionen zu koordinieren.
MenuFlyout-Updates | Für universelle Windows-Apps sind neue APIs verfügbar, mit denen Sie noch einfacher bessere Kontextmenüs erstellen können. Mit der neuen Methode [MenuFlyout.ShowAt](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.menuflyout.showat) können Sie angeben, wo der Flyout in Bezug auf ein anderes Element angezeigt werden soll. (Und Ihr MenuFlyout kann sogar die Grenzen des App-Fensters überlappen.) Verwenden Sie die neue Klasse [MenuFlyoutSubItem](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.menuflyoutsubitem), um Untermenüs zu erstellen.
Neue Rahmeneigenschaften für ContentPresenter, Grid und StackPanel | Allgemeine Containersteuerelemente haben neue Rahmeneigenschaften, mit denen Sie einen Rahmen um sie herum zeichnen können, ohne ein zusätzliches Rahmenelement Ihrer XAML hinzuzufügen. [ContentPresenter](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.contentpresenter), [Grid](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.grid) und [StackPanel](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.stackpanel) weisen diese neuen Eigenschaften auf: BorderBrush, BorderThickness, CornerRadius und Padding.
Neue Text-APIs für ContentPresenter | [ContentPresenter](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.contentpresenter) verfügt über neue APIs, mit denen Sie mehr Kontrolle über die Textanzeige haben: LineHeight, LineStackingStrategy, MaxLines und TextWrapping.
Visuelle Systemfokuselemente | Visuelle Fokuselemente für XAML-Steuerelemente werden jetzt vom System erstellt und nicht mehr als XAML-Elemente in der Steuerelementvorlage deklariert. Die visuellen Fokus-Elemente sind normalerweise bei mobilen Geräten nicht erforderlich, und das Erstellen und Verwalten nach Bedarf durch das System verbessert die App-Leistung. Wenn Sie eine bessere Kontrolle über visuelle Fokuselemente benötigen, können Sie das Systemverhalten überschreiben und eine benutzerdefinierte Steuerelementvorlage zur Verfügung stellen, mit der visuelle Fokuselemente definiert werden. Weitere Informationen finden Sie unter [UseSystemFocusVisuals](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.usesystemfocusvisuals) und [IsTemplateFocusTarget](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.istemplatefocustargetproperty).
PasswordBox.PasswordRevealMode | In universellen Windows-Apps wird die IsPasswordRevealButtonEnabled-Eigenschaft durch die [PasswordRevealMode](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.passwordbox.passwordrevealmode)-Eigenschaft ersetzt, um ein einheitliches Verhalten in allen Gerätefamilien zu gewährleisten. **Vorsicht:** Vor Windows 10 wurde die Schaltfläche für die Kennwortanzeige nicht standardmäßig angezeigt. In universellen Windows-Apps wird sie dagegen standardmäßig angezeigt. Wenn die Sicherheit Ihrer App erfordert, dass das Kennwort immer verdeckt ist, muss „PasswordRevealMode“ auf „Hidden“ festgelegt werden.
Control.IsTextScaleFactorEnabled | Die [IsTextScaleFactorEnabled](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.istextscalefactorenabledproperty)-Eigenschaft, die unter Windows Phone 8.1 verfügbar war, ist jetzt für universelle Windows-Apps in allen Gerätefamilien verfügbar.
AutoSuggestBox | Das [AutoSuggestBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.autosuggestbox)-Steuerelement aus Windows Phone 8.1 ist jetzt für universelle Windows-Apps in allen Gerätefamilien verfügbar und sollte anstelle von [SearchBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.searchbox) verwendet werden. AutoSuggestBox liefert Vorschläge während der Benutzereingabe und funktioniert gut mit verschiedenen Eingabetypen wie Touch, Tastatur und Eingabemethoden-Editoren. Es verfügt außerdem über einige neue Member, damit es besser als Suchfeld funktioniert: die [QueryIcon](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.autosuggestbox.queryicon)-Eigenschaft und das [QuerySubmitted](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.autosuggestbox.querysubmitted)-Ereignis.
ContentDialog | Das [ContentDialog](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.contentdialog)-Steuerelement aus Windows Phone 8.1 ist jetzt für universelle Windows-Apps in allen Gerätefamilien verfügbar. Mit „ContentDialog“ können Sie ein anpassbares modales Dialogfeld anzeigen, das auf sämtlichen Geräten einwandfrei funktioniert.
Pivot | Das [Pivot](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.pivot)-Steuerelement aus Windows Phone 8.1 ist jetzt für universelle Windows-Apps in allen Gerätefamilien verfügbar. Jetzt können Sie dasselbe Pivot-Steuerelement in Ihrer App für Mobilgeräte und Desktopgeräte verwenden. Pivot enthält adaptives Verhalten, das auf Bildschirmgröße und Eingabetyp basiert. Sie können ein Pivot-Steuerelement so gestalten, dass es ein registerkartenähnliches Verhalten zeigt – mit verschiedenen Ansichten der Informationen in jedem Pivot-Element.

## <a name="text"></a>Text

Feature | Beschreibung
 :---- | :----
Windows Core-Text-APIs | Der neue Namespace [Windows.UI.Text.Core](https://docs.microsoft.com/uwp/api/windows.ui.text.core) verfügt über ein Client-Server-System, das die Verarbeitung von Eingaben über die Tastatur auf einem Server zentralisiert. Sie können es verwenden, um den Bearbeitungspuffer Ihres benutzerdefinierten Steuerelements zur Texteingabe zu bearbeiten. Der Texteingabeserver garantiert, dass der Inhalt Ihres Steuerelements zur Texteingabe und der Inhalt seines eigenen Bearbeitungspuffers über einen asynchronen Kommunikationskanal zwischen der App und dem Server immer synchron gehalten werden.
Vektorsymbole | Das Element [Glyphen](https://docs.microsoft.com/uwp/api/windows.ui.xaml.documents.glyphs) verfügt über die neuen Eigenschaften [IsColorFontEnabled](https://docs.microsoft.com/uwp/api/windows.ui.xaml.documents.glyphs.iscolorfontenabled) und [ColorFontPalleteIndex](https://docs.microsoft.com/uwp/api/windows.ui.xaml.documents.glyphs.colorfontpaletteindex) für die Unterstützung von Schriftarten. Jetzt können Sie eine Schriftartdatei zum Rendern schriftartbasierter Symbole verwenden. Bei Verwendung von ColorFontPalleteIndex für das Wechseln der Farbpalette kann ein einzelnes Symbol mit verschiedenen Farbzusammenstellungen gerendert werden, z. B. um eine aktivierte und deaktivierte Version des Symbols anzuzeigen.
Eingabemethoden-Editor für Windows-Ereignisse | Benutzer geben manchmal Text über einen Eingabemethoden-Editor ein, der in einem Fenster direkt unterhalb eines Texteingabefelds angezeigt wird (in der Regel für ostasiatische Sprachen). Sie können das CandidateWindowBoundsChanged-Ereignis und die DesiredCandidateWindowAlignment-Eigenschaft für [TextBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.textbox) und [RichEditBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.richeditbox) verwenden, damit die Benutzeroberfläche Ihrer App mit dem IME-Fenster besser funktioniert.
Textkompositionsereignisse | [TextBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.textbox) und [RichEditBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.richeditbox) verfügen über folgende neue Ereignisse, die Ihre App darüber informieren, wenn Text mithilfe eines Eingabemethoden-Editors eingegeben wird: TextCompositionStarted, TextCompositionEnded und TextCompositionChanged. Sie können diese Ereignisse behandeln, um Ihren App-Code mit dem IME-Textkompositionsprozess zu koordinieren. Sie können z. B. eine Inlinefunktion zur automatischen Vervollständigung für ostasiatische Sprachen implementieren.
Verbesserte Handhabung von bidirektionalem Text | XAML-Textsteuerelemente verfügen über eine neue API zur verbesserten Behandlung von bidirektionalem Text, was eine bessere Textausrichtung und Absatzrichtung für eine Vielzahl von Eingabesprachen ergibt. Der Standardwert der Eigenschaft TextReadingOrder wurde auf DetectFromContent geändert. Dadurch ist die Unterstützung zur Erkennung der Lesereihenfolge standardmäßig aktiviert. Die Eigenschaft TextReadingOrder wurde auch bei PasswordBox, RichEditBox und TextBox hinzugefügt. Sie können die Eigenschaft TextAlignment auf Text-Steuerelementen an der neuen DetectFromContent-Wert für Opt-In einstellen, damit die Ausrichtung vom Inhalt automatisch erkannt wird.
Rendering von Text | In Windows 10 wird der Text in XAML-Apps jetzt in den meisten Fällen mit der zweifachen Geschwindigkeit von Windows 8.1 gerendert. In den meisten Fällen werden Ihre Apps von diese Verbesserung ohne Änderungen profitieren. Neben dem schnelleren Rendern reduzieren diese Verbesserungen auch die typische Speicherauslastung der XAML-Apps um fünf Prozent.

## <a name="application-model"></a>Anwendungsmodell

Feature | Beschreibung
 :---- | :----
Cortana | Erweitern Sie die Grundfunktionen von Cortana durch Sprachbefehle, die eine einzelne Aktion in einer externen Anwendung starten und ausführen. Cortana integriert die grundlegenden Funktionen Ihrer App, bietet einen zentralen Einstiegspunkt, über den der Benutzer die meisten Aufgaben ohne Öffnen der App ausführen kann, und wird somit zum Bindeglied zwischen Ihrer App und dem Benutzer. In vielen Fällen spart der Benutzer dadurch viel Zeit und Mühe. Hier erfahren Sie, wie Sie [Ihre App in die Cortana-Canvas integrieren](https://docs.microsoft.com/previous-versions/windows/apps/dn974230(v=win.10)). In den speziell für Cortana geschriebenen Entwurfsempfehlungen und Richtlinien für die Gestaltung der Benutzeroberfläche unter [Designgrundlagen für universelle Windows-Apps](https://docs.microsoft.com/windows/uwp/design/layout/index) finden Sie wertvolle Anregungen.
Datei-Explorer | Mit den neuen [Windows.System.Launcher.LaunchFolderAsync](https://docs.microsoft.com/uwp/api/windows.system.launcher.launchfolderasync)-Methoden können Sie den Datei-Explorer starten und den Inhalt eines von Ihnen angegebenen Ordners anzeigen.
Freigegebener Speicher | Mit der neuen [Windows.ApplicationModel.DataTransfer.SharedStorageAccessManager](https://docs.microsoft.com/uwp/api/windows.applicationmodel.datatransfer.sharedstorageaccessmanager) -Klasse und den zugehörigen Methoden können Sie eine Datei mit einer anderen App teilen, indem Sie ein Freigabetoken weiterleiten, wenn Sie die andere App mithilfe der URI-Aktivierung starten. Die Ziel-App löst das Token ein, um die von der Quell-App geteilte Datei abzurufen.
Einstellungen | Verwenden Sie das ms-settings-Protokoll mit der [LaunchUriAsync](https://docs.microsoft.com/uwp/api/windows.system.launcher.launchuriasync)-Methode, um integrierte Einstellungsseiten anzuzeigen. Der folgende Code zeigt beispielsweise die Seite mit den WLAN-Einstellungen an: **bool result = await Launcher.LaunchUriAsync(new Uri("ms-settings://network/wifi"));** <br /><br />Eine Liste der Einstellungsseiten, die Sie anzeigen können, finden Sie unter [Anzeigen integrierter Einstellungsseiten mithilfe des ms-settings-Protokolls](https://docs.microsoft.com/previous-versions/windows/apps/jj207014(v=vs.105)).
App-zu-App-Kommunikation | Neue APIs unter Windows 10 für die [App-zu-App-Kommunikation](https://docs.microsoft.com/previous-versions/windows/apps/dn997827(v=win.10)) ermöglichen Windows-Anwendungen (und Windows-Webanwendungen) das gegenseitige Starten und das Austauschen von Daten und Dateien. Dank dieser neuen APIs können komplexe Aufgaben, für die Benutzer bisher mehrere Anwendungen nutzen mussten, jetzt nahtlos durchgeführt werden. Mit Ihrer App kann beispielsweise eine App für ein soziales Netzwerk gestartet werden, um einen Kontakt auszuwählen, oder eine Kassenanwendung, um einen Bezahlvorgang durchzuführen.
App-Dienste | Ein App-Dienst stellt für ein App eine Möglichkeit dar, für andere Apps unter Windows 10 Dienste bereitzustellen. Ein App-Dienst wird als Hintergrundaufgabe ausgeführt. Vordergrund-Apps können einen App-Dienst in einer anderen App aufrufen, um Aufgaben im Hintergrund auszuführen. Referenzinformationen zur API für App-Dienste finden Sie unter [Windows.ApplicationModel.AppService](https://docs.microsoft.com/uwp/api/Windows.ApplicationModel.AppService).
App-Paketmanifest | Die Aktualisierungen der [Paketmanifestschema](https://docs.microsoft.com/uwp/schemas/appxpackage/appx-package-manifest)-Referenz für Windows 10 enthalten auch Elemente, die hinzugefügt, entfernt oder geändert wurden. Unter [Elementhierarchie](https://docs.microsoft.com/uwp/schemas/appxpackage/uapmanifestschema/root-elements) finden Sie Referenzinformationen zu allen Elementen, Attributen und Typen im Schema.

## <a name="devices"></a>Geräte

Feature | Beschreibung
 :---- | :----
Microsoft Surface Hub | Der Microsoft Surface Hub ist ein leistungsfähiges Gerät für die Teamarbeit und eine großformatige Anzeigeplattform für universelle Windows-Apps, die direkt auf dem Surface Hub oder auf einem angeschlossenen Gerät ausgeführt werden. Entwickeln Sie eigene, speziell auf Ihr Unternehmen ausgerichtete Apps, die Vorteile wie Großbildschirm, Touch- und Freihandeingabe und umfassende integrierte Hardware wie Kameras und Sensoren optimal nutzen.<br /><br />Unter [Designgrundlagen für universelle Windows-Apps](https://docs.microsoft.com/windows/uwp/design/layout/index) finden Sie Entwurfsempfehlungen und Richtlinien für die Gestaltung der Benutzeroberfläche, die sich speziell auf den Surface-Hub beziehen. In diesen Dokumenten werden Techniken für reaktionsfähiges Design für universelle Windows-Apps erläutert. <br /><br />Ausführliche Informationen zur Unterstützung freigegebener Apps finden Sie unter [SharedModeSettings](https://docs.microsoft.com/uwp/api/windows.system.profile.sharedmodesettings). Informationen zur Freihandeingabe und Details zur Unterstützung der Multipoint-Freihandeingabe im neuen [InkCanvas](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.inkcanvas)-Steuerelement finden Sie unter [Windows.UI.Input.Inking](https://docs.microsoft.com/uwp/api/windows.ui.input.inking) und [Windows.UI.Input.Inking.Core](https://docs.microsoft.com/uwp/api/windows.ui.input.inking.core). Informationen zur Verarbeitung von Sensoreingaben finden Sie unter [Integrieren von Geräten, Druckern und Sensoren](https://docs.microsoft.com/previous-versions/windows/apps/br229563(v=win.10)).
Pfad | In Windows 10 wird mit [RequestAccessAsync](https://docs.microsoft.com/uwp/api/windows.devices.geolocation.geolocator.requestaccessasync) eine neue Methode zum Anfordern der Benutzerberechtigung für den Zugriff auf Positionsdaten eingeführt. Der Benutzer legt den Schutz seiner Positionsdaten über **Datenschutzeinstellungen für den Standort** in der App **Einstellungen** fest. Die App kann nur unter folgenden Voraussetzungen auf die Position des Benutzers zugreifen: **Position dieses Geräts** ist aktiviert *(gilt nicht für Windows 10 für Smartphones)* , die Einstellung **Position** der Positionsdienste ist aktiviert, und Ihre App ist unter **Wählen Sie Apps aus, die Ihre Position verwenden dürfen** aktiviert. <br /><br />Wichtig: Die Methode **RequestAccessAsync** muss aufgerufen werden, bevor Sie auf den Standort des Benutzers zugreifen. Zu diesem Zeitpunkt muss sich Ihre App im Vordergrund befinden, und **RequestAccessAsync** muss vom UI-Thread aufgerufen werden. Solange der Benutzer Ihrer App keinen Zugriff auf seine Position gewährt hat, kann Ihre App nicht auf Positionsdaten zugreifen.
AllJoyn | Mit dem Windows-Runtime-Namespace [Windows.Devices.AllJoyn](https://docs.microsoft.com/uwp/api/windows.devices.alljoyn) wird die Microsoft-Implementierung von AllJoyn-Open Source-Softwareframework und -diensten eingeführt. Über diese APIs kann sich Ihre universelle Windows-App eines Geräts an IoT (Internet der Dinge, Internet of Things)-Szenarien mit anderen Geräten beteiligen, die über AllJoyn gesteuert werden. Weitere Details über die AllJoyn C-APIs erhalten Sie, wenn Sie die Dokumentation unter [The AllSeen Alliance](https://allseenalliance.org/) herunterladen. Mit dem in dieser Version enthaltenen Tool [AllJoynCodeGen](https://docs.microsoft.com/previous-versions/windows/apps/dn913809(v=win.10)) generieren Sie eine Windows-Komponente, mit der Sie AllJoyn-Szenarien für Ihre Geräte-App ermöglichen. <br /><br />**Hinweis:** Windows 10 IoT Core ist jetzt für eine neue Klasse kleiner Geräte verfügbar, sodass Sie IoT-Geräte (Internet der Dinge) mit Windows und Visual Studio erstellen können. Weitere Informationen finden Sie unter [Windows IoT im Windows Dev Center](https://developer.microsoft.com/windows/iot).
Druck-APIs auf mobilen Geräten (XAML) | Es gibt eine einzelne einheitliche Gruppe von APIs, mit denen Sie unabhängig von der Gerätefamilie in Ihren XAML-basierten UWP-Apps drucken können. Dies schließt auch mobile Geräte mit ein. Sie können Ihrer App jetzt mithilfe bekannter druckbezogener APIs aus den Windows.Graphics.Printing- und Windows.UI.Xaml.Printing-Namespaces eine Druckfunktion hinzufügen.
Akku | Mit den Akku-APIs im [Windows.Devices.Power](https://docs.microsoft.com/uwp/api/windows.devices.power)-Namespace erhält Ihre App zusätzliche Informationen zu sämtlichen Akkus des Geräts, auf dem Ihre App ausgeführt wird. Erstellen Sie ein [Battery](https://docs.microsoft.com/uwp/api/windows.devices.power.battery)-Objekt, das einen einzelnen Battery-Controller oder eine Sammlung sämtlicher Battery-Controller darstellt (wenn mit [FromIdAsync](https://docs.microsoft.com/uwp/api/windows.devices.power.battery.fromidasync) oder [AggregateBattery](https://docs.microsoft.com/uwp/api/windows.devices.power.battery.aggregatebattery) erstellt). Verwenden Sie die [GetReport](https://docs.microsoft.com/uwp/api/windows.devices.power.battery.getreport)-Methode zum Zurückgeben eines [BatteryReport](https://docs.microsoft.com/uwp/api/windows.devices.power.batteryreport)-Objekts, mit dem die Ladung, die Kapazität und der Status der entsprechenden Akkus angegeben wird.
MIDI-Geräte | Mit dem neuen [Windows.Devices.Midi](https://docs.microsoft.com/uwp/api/windows.devices.midi)-Namespace können Sie Folgendes erstellen: Apps, die mit externen MIDI-Geräten kommunizieren, Apps und externe Geräte, die direkt mit dem Microsoft GS MIDI-Softwaresynthesizer kommunizieren, und Szenarien, in denen mehrere Clients gleichzeitig auf einen einzelnen MIDI-Port zugreifen.
Benutzerdefinierte Sensorunterstützung | Der [Windows.Devices.Sensors.Custom](https://docs.microsoft.com/uwp/api/windows.devices.sensors.custom)-Namespace ermöglicht Hardwareentwicklern die Definition neuer benutzerdefinierter Sensortypen, z. B. eines CO2-Sensors.
Hostbasierte Kartenemulation (HCE) | Bei der hostbasierten Kartenemulation können Sie die im Betriebssystem gehosteten NFC-Kartenemulationsdienste implementieren und per NFC-Funkverbindung weiterhin mit der externen Lesegeräteinheit kommunizieren. Wenn Sie eine Hintergrundaufgabe zur Emulierung einer Smartcard per NFC auslösen möchten, verwenden Sie die [SmartCardTrigger](https://docs.microsoft.com/uwp/api/Windows.ApplicationModel.Background.SmartCardTrigger)-Klasse. Mit dem EmulatorHostApplicationActivated-Wert in der Aufzählung [SmartCardTriggerType](https://docs.microsoft.com/uwp/api/Windows.Devices.SmartCards.SmartCardTriggerType) wird der App mitgeteilt, dass ein HCE-Ereignis eingetreten ist.

## <a name="graphics"></a>Grafiken

Feature | Beschreibung
 :---- | :----
DirectX | DirectX 12 in Windows 10 führt die nächste Version von Microsoft Direct3D ein, der 3D-Grafik-API im Herzen von DirectX. [Direct3D 12 Graphics](https://docs.microsoft.com/windows/desktop/direct3d12/direct3d-12-graphics) bietet die Effizienz und Leistung einer konsolenähnlichen API auf niedriger Ebene. Direct3D 12 ist schneller und effizienter als je zuvor. Es ermöglicht detailliertere Szenen, mehr Objekte, komplexere Effekte und eine bessere Nutzung moderner Grafikhardware.
SoftwareBitmapSource | In universellen Windows-Apps können Sie den neuen Typ [SoftwareBitmapSource](https://docs.microsoft.com/uwp/api/windows.ui.xaml.media.imaging.softwarebitmapsource) wie eine XAML-Bildquelle verwenden. Dadurch können Sie uncodierte Bilder an das XAML-Framework weiterleiten, um sie sofort auf dem Bildschirm anzuzeigen, indem Sie die Bilddecodierung durch das XAML-Framework umgehen. Sie können viel schnelleres Rendering von Bildern erreichen, z. B. das Rendern von Fotos mit niedriger Verzögerung direkt von der Kamera, mithilfe von benutzerdefinierten Bild-Decodern, Sammeln von Rahmen von DirectX-Oberflächen oder sogar im Arbeitsspeicher Bilder von Grund auf neu erstellen und alle direkt in XAML mit geringer Latenz und niedrigen Speicherbedarf rendern.
Perspektivische Kamera | In universellen Windows-Apps verfügt XAML über eine neue Transform3D-API, mit der Sie perspektivische Transformationen auf eine XAML-Struktur (oder Szene) anwenden können. Dadurch werden alle untergeordneten XAML-Elemente gemäß dieser einzelnen Szenentransformation (oder Kamera) transformiert. Durch Verwendung von MatrixTransform und komplexer Mathematik war das auch früher möglich, aber Transform3D stellt eine drastische Vereinfachung dieses Effekts dar und ermöglicht auch den Effekt, animiert zu werden. Weitere Informationen finden Sie unter der Eigenschaft [UIElement.Transform3D](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.transform3d), [Transform3D](https://docs.microsoft.com/uwp/api/windows.ui.xaml.media.media3d.transform3d), [CompositeTransform3D](https://docs.microsoft.com/uwp/api/windows.ui.xaml.media.media3d.compositetransform3d) und [PerspectiveTransform3D](https://docs.microsoft.com/uwp/api/windows.ui.xaml.media.media3d.perspectivetransform3d).

## <a name="media"></a>Media

Feature | Beschreibung
 :---- | :----
HTTP Live Streaming | Mit der neuen [AdaptiveMediaSource](https://docs.microsoft.com/uwp/api/windows.media.streaming.adaptive.adaptivemediasource)-Klasse können Sie Ihre Apps mit Funktionen für adaptives Videostreaming ausstatten. Das Objekt wird initialisiert, wenn es auf eine Streaming-Manifest-Datei verweist. Zu den unterstützten Manifestformaten gehören HTTP Live Streaming (HLS) und Dynamic Adaptive Streaming over HTTP (DASH). Sobald das Objekt an ein XAML-Medienelement gebunden ist, beginnt die anpassungsfähige Wiedergabe. Eigenschaften des Datenstroms, wie etwa die verfügbare, minimale und maximale Bitrate, können abgefragt und bei Bedarf festgelegt werden.
Media Foundation Transcode Video Processor (XVP)-Unterstützung für Media Foundation-Transformationen (MFTs) | Windows-Apps, die Media Foundation-Transformationen (MFTs) verwenden, können jetzt den **Media Foundation Transcode Video Processor** (XVP) zum Konvertieren, Skalieren und Transformieren von Rohvideodaten verwenden: Das neue [MF_XVP_CALLER_ALLOCATES_OUTPUT](https://docs.microsoft.com/windows/desktop/medfound/mf-xvp-caller-allocates-output)-Attribut ermöglicht selbst im Microsoft DirectX Video Acceleration (DXVA)-Modus die Ausgabe an Texturen, die dem Aufrufer zugeordnet sind. Mit der neuen [IMFVideoProcessorControl2](https://docs.microsoft.com/windows/desktop/api/mfidl/nn-mfidl-imfvideoprocessorcontrol2)-Schnittstelle kann Ihre App Hardwareeffekte aktivieren, unterstützte Hardwareeffekte abfragen und den vom Videoprozessor durchgeführten Drehvorgang außer Kraft setzen.
Transcodierung | Mithilfe der neuen [MediaProcessingTrigger](https://docs.microsoft.com/uwp/api/Windows.ApplicationModel.Background.MediaProcessingTrigger)-API kann Ihre App die Medientranscodierung als Hintergrundaufgabe ausführen, sodass die Transcodierungsvorgänge auch dann fortgesetzt werden können, wenn die App nicht mehr im Vordergrund angezeigt wird.
Fehlerereignisse bei MediaElement-Medien | In universellen Windows-Apps gibt das [MediaElement](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.MediaElement) auch dann Inhalte mit mehreren Datenströmen wieder, wenn beim Decodieren eines der Datenströme ein Fehler auftritt (vorausgesetzt, die Medieninhalte enthalten mindestens einen gültigen Datenstrom). Wenn z. B. bei einem Videostream in einem Content, der einen Audio- und einen Videostream umfasst, ein Fehler auftritt, gibt [MediaElement](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.MediaElement) den Audiostream dennoch wieder. [PartialMediaFailureDetected](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaelement.partialmediafailuredetected) benachrichtigt Sie, dass einer der Streams in einem Stream nicht decodiert werden konnte. Sie werden auch informiert, bei welchem Streamtyp der Fehler aufgetreten ist, damit Sie diese Informationen in der UI wiedergeben können. Wenn auf allen Datenströmen innerhalb eines Mediums Fehler auftreten, wird das Ereignis [MediaFailed](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaelement.mediafailed) ausgelöst.
Unterstützung für adaptives Videostreaming mit MediaElement | [MediaElement](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.MediaElement) verfügt zur Unterstützung von adaptivem Videostreaming über die neue Methode [SetPlaybackSource](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaelement.setplaybacksource). Verwenden Sie diese Methode, um Ihre Medienquelle auf eine AdaptiveMediaSource einzustellen.
Wiedergabe mit MediaElement und Image | Die Steuerelemente [MediaElement](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.MediaElement) und Image verfügen über die neue Methode [GetAsCastingSource](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaelement.getascastingsource). Mit dieser Methode können Sie Inhalte von allen Medien- oder Bildelementen an einen breiteren Bereich von Remotegeräten wie Miracast, Bluetooth und DLNA programmgesteuert senden. Diese Funktion ist automatisch aktiviert, wenn Sie [AreTransportControlsEnabled](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaelement.aretransportcontrolsenabled) auf einem MediaElement-Objekt auf TRUE festlegen.
Medientransport-Steuerelemente für Desktop-Apps | Die Schnittstelle [ISystemMediaTransportControls](https://docs.microsoft.com/previous-versions/windows/desktop/mediatransport/isystemmediatransportcontrols) und verwandte APIs ermöglichen Desktop-Apps die Interaktion mit den integrierten Transportsteuerelementen. Dazu zählen die Reaktion auf Benutzerinteraktionen mit den Schaltflächen für die Transportsteuerung und die Aktualisierung der Anzeige für die Transportsteuerung, um Metadaten zu den derzeit wiedergegebenen Medieninhalten anzuzeigen.
JPEG-Codierung und-Decodierung mit wahlfreiem Zugriff | Die neuen WIC-Methoden [IWICJpegFrameEncode](https://docs.microsoft.com/windows/desktop/api/wincodec/nn-wincodec-iwicjpegframeencode) und [IWICJpegFrameDecode](https://docs.microsoft.com/windows/desktop/api/wincodec/nn-wincodec-iwicjpegframedecode) ermöglichen das Codieren und Decodieren von JPEG-Bildern. Sie können jetzt auch die Indizierung der Bilddaten aktivieren, wodurch effizienter wahlfreier Zugriff auf große Bilder ermöglicht wird, der aber auch einen größeren Speicherbedarf verursacht.
Überlagerungen für Medienkompositionen | Die neuen [MediaOverlay](https://docs.microsoft.com/uwp/api/Windows.Media.Editing.MediaOverlay)- und [MediaOverlayLayer](https://docs.microsoft.com/uwp/api/Windows.Media.Editing.MediaOverlayLayer)-APIs erleichtern das Hinzufügen von mehreren Ebenen statischer oder dynamischer Medieninhalte zu einer Medienkomposition. Deckkraft, Position und zeitliche Steuerung können für jede Ebene angepasst werden, und Sie können auch Ihren eigenen benutzerdefinierten Kompositor für Eingabeebenen implementieren.
Framework mit neuen Effekten | Der [Windows.Media.Effects](https://docs.microsoft.com/uwp/api/windows.media.effects)-Namespace bietet ein einfaches und intuitives Framework zum Hinzufügen von Effekten zu Audio- und Videostreams. Das Framework enthält grundlegende Schnittstellen, die zum Erstellen von benutzerdefinierten Audio- und Videoeffekten und zum Einfügen in die Medienpipeline implementiert werden können.

## <a name="networking"></a>Netzwerk

Feature | Beschreibung
 :---- | :----
Sockets | Socketaktualisierungen: <br /><br />**Socketbroker:** Der Socket-Broker kann Socket-Verbindungen im Auftrag einer App in jeder Phase des App-Lebenszyklus herstellen und beenden. So können Apps und die Dienste, die sie bereitstellen, besser gefunden werden. Zum Beispiel kann ein Win32-Dienst eingehende Socketverbindungen auch dann über den Socketbroker annehmen, wenn er nicht ausgeführt wird. <br /><br />**Verbesserungen beim Durchsatz:** Der Socketdurchsatz wurde für Apps optimiert, die den Windows.Networking.Sockets-Namespace verwenden.
Nachbearbeitungsaufgaben für die Hintergrundübertragung | Mit den neuen APIs im [Windows.Networking.BackgroundTransfer](https://docs.microsoft.com/uwp/api/windows.networking.backgroundtransfer)-Namespace können Sie Gruppen von Nachbearbeitungsaufgaben registrieren. Ihre App kann Hintergrundübertragungen dadurch sofort durchführen, auch wenn sie nicht im Vordergrund ausgeführt wird, und muss nicht warten, bis der Benutzer die App wieder startet.
Bluetooth-Unterstützung für Anzeigen | Mit dem [Windows.Devices.Bluetooth.Advertisement](https://docs.microsoft.com/uwp/api/windows.devices.bluetooth.advertisement)-Namespace kann Ihre App Bluetooth LE-Werbung senden, empfangen und filtern.
Wi-Fi Direct-API-Update | Der Gerätebroker wird aktualisiert, um die Kopplung mit Geräten zu ermöglichen, ohne die App zu verlassen. Mit den Erweiterungen des [Windows.Devices.WiFiDirect](https://docs.microsoft.com/uwp/api/windows.devices.wifidirect)-Namespace kann sich ein Gerät auch für andere Geräte sichtbar machen und auf eingehende Verbindungsbenachrichtigungen lauschen.<br /><br />**Hinweis:** In diesem Release sind die Verbesserungen am Wi-Fi Direct-Feature nicht in die UX integriert und unterstützen nur die Kopplung per Tastendruck. Außerdem unterstützt diese Version nur eine aktive Verbindung.
Verbesserungen an der JSON-Unterstützung | Der [Windows.Data.Json](https://docs.microsoft.com/uwp/api/windows.data.json)-Namespace unterstützt vorhandene Standarddefinitionen und die Entwicklerumgebung nun besser bei der Konvertierung von JSON-Objekten in Debugsitzungen.

## <a name="security"></a>Sicherheit

Feature | Beschreibung
 :---- | :----
ECC-Verschlüsselung | Neue APIs im [Windows.Security.Cryptography](https://docs.microsoft.com/uwp/api/windows.security.cryptography)-Namespace bieten Unterstützung für Elliptical Curve Cryptography (ECC). Hierbei handelt es sich um eine Kryptografieimplementierung mit öffentlichem Schlüssel auf der Grundlage elliptischer Kurven über begrenzten Feldern. ECC ist mathematisch komplexer als RSA, bietet kleinere Schlüsselgrößen, verringert die Arbeitsspeichernutzung und verbessert die Leistung. Sie bietet Microsoft-Diensten und -Kunden eine Alternative zu RSA-Schlüsseln und den von NIST genehmigten Kurvenparametern.
Microsoft Passport | Microsoft Passport ist eine alternative Authentifizierungsmethode, bei der Kennwörter durch eine asymmetrische Verschlüsselung und eine Geste ersetzt werden. Dank der Klassen im Credentials-Namespace, z. B. [KeyCredentialManager](https://docs.microsoft.com/uwp/api/windows.security.credentials.keycredentialmanager), ist es für Entwickler einfach, eine Anwendung mit Microsoft Passport zu erstellen, ohne die komplexen Anforderungen der Verschlüsselung oder Biometrie erfüllen zu müssen.
Microsoft Passport for Work | Microsoft Passport for Work ist eine alternative Methode für die Anmeldung an Windows. Dabei wird Ihr Azure Active Directory-Konto genutzt, für das keine Kennwörter, Smartcards und virtuellen Smartcards verwendet werden. Sie können auswählen, ob Sie diese Richtlinieneinstellung aktivieren oder deaktivieren möchten.
Token Broker | Token Broker ist ein neues Authentifizierungs-Framework, mit dem es Apps erleichtert wird, eine Verbindung mit Online-Identitätsanbietern (z. B. Facebook) herzustellen. Features wie die Verwaltung von Kontobenutzernamen und -kennwörtern sowie eine optimierte UI stellen für Benutzer eine deutliche Verbesserung bei der Authentifizierung dar.

## <a name="system-services"></a>Systemdienste

Feature | Beschreibung
 :---- | :----
Stromversorgung | Ihre Windows-Desktopanwendung kann jetzt benachrichtigt werden, wenn der Stromsparmodus aktiviert oder deaktiviert wird. Durch die Berücksichtigung der veränderten Leistungsaufnahme kann die Anwendung dazu beitragen, die Akkulaufzeit zu verlängern. <br /><br />[GUID_POWER_SAVING_STATUS](https://docs.microsoft.com/windows/desktop/Power/power-setting-guids): Verwenden Sie diese neue GUID mit der [PowerSettingRegisterNotification](https://docs.microsoft.com/windows/desktop/api/powersetting/nf-powersetting-powersettingregisternotification)-Funktion, um benachrichtigt zu werden, wenn der Stromsparmodus aktiviert oder deaktiviert wird. <br /><br />[SYSTEM_POWER_STATUS](https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-_system_power_status): Diese Struktur wurde aktualisiert, um den Stromsparmodus zu unterstützen. Die vierte Option, *SystemStatusFlag* (früher „Reserved1“), gibt jetzt an, ob der Stromsparmodus aktiviert ist oder nicht. Verwenden Sie die [GetSystemPowerStatus](https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getsystempowerstatus)-Funktion, um einen Zeiger auf diese Struktur abzurufen.
Version | Mithilfe der [Versionsabfrage-Funktionen](https://docs.microsoft.com/windows/desktop/SysInfo/version-helper-apis) können Sie die Version des Betriebssystems ermitteln. Unter Windows 10 wurden diese Hilfsfunktionen um die neue Funktion [IsWindows10OrGreater](https://docs.microsoft.com/windows/desktop/api/versionhelpers/nf-versionhelpers-iswindows10orgreater) erweitert. Zur Abfrage der Systemversion sollten Sie diese Hilfsfunktionen anstelle der veralteten Funktionen [GetVersionEx](https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversionexa) und [GetVersion](https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversion) verwenden. Weitere Informationen zum Abfragen der Systemversion finden Sie unter [Abrufen der Systemversion](https://docs.microsoft.com/windows/desktop/SysInfo/getting-the-system-version). <br /><br />Wenn Sie die veralteten Funktionen [GetVersionEx](https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversionexa) oder [GetVersion](https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversion) verwenden, um die Versionsinformationen in einer [OSVERSIONINFOEX](https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-_osversioninfoexa)- oder [OSVERSIONINFO](https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-_osversioninfoa)-Struktur abzurufen, berücksichtigen Sie, dass die darin enthaltenen Versionsnummern von 6.3 (für Windows 8.1 und Windows Server 2012 R2) auf 10.0 (für Windows 10) erhöht werden. Weitere Informationen zu Versionsnummern des Betriebssystems finden Sie unter [Version des Betriebssystems](https://docs.microsoft.com/windows/desktop/SysInfo/operating-system-version). <br /><br />Außerdem müssen Sie Ihre Anwendung explizit auf Windows 8.1 oder Windows 10 ausrichten, um mithilfe der Funktionen [GetVersionEx](https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversionexa) oder [GetVersion](https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversion) die richtigen Versionsinformationen für diese Versionen abzurufen. Weitere Informationen dazu, wie Sie die Anwendung auf diese Windows-Versionen ausrichten, finden Sie unter [Ausrichten Ihrer Anwendung auf Windows](https://docs.microsoft.com/windows/desktop/SysInfo/targeting-your-application-at-windows-8-1).
Benutzerinformationen | Neue APIs im [Windows.System](https://docs.microsoft.com/uwp/api/windows.system)-Namespace erleichtern Ihnen den Zugriff auf Informationen zum Benutzer, z. B. auf den Benutzernamen und das Profilbild. Außerdem ist es möglich, auf Benutzerereignisse zu reagieren, z. B. das Anmelden und Abmelden.
Speicherverwaltung und Profilerstellung | Die Unterstützung der API zur Erstellung von Arbeitsspeicherprofilen in [Windows.System](https://docs.microsoft.com/uwp/api/windows.system) wurde auf alle Plattformen ausgedehnt, und die allgemeine Funktionalität wurde durch neue Klassen und Funktionen erweitert.

## <a name="storage"></a>Speicher

Feature | Beschreibung
 :---- | :----
Für Windows Phone verfügbare APIs für die Dateisuche | Als App-Herausgeber können Sie dem App-Manifest Erweiterungen hinzufügen und so Ihre App registrieren, damit sie mit anderen von Ihnen veröffentlichten Apps einen gemeinsamen Speicherordner nutzt. Rufen Sie dann mithilfe der [Windows.Storage.ApplicationData.GetPublisherCacheFolder](https://docs.microsoft.com/uwp/api/windows.storage.applicationdata.getpublishercachefolder)-Methode den freigegebenen Speicherort auf. Das starke Sicherheitskonzept von Windows-Runtime-Apps verhindert gewöhnlich, dass Apps Daten untereinander teilen. Bei Apps des gleichen Herausgebers kann aber unter Umständen eine benutzerspezifische gemeinsame Nutzung von Dateien und Einstellungen hilfreich sein.

## <a name="tools"></a>Tools

Feature | Beschreibung
 :---- | :----
Visuelle Live-Struktur in Visual Studio | Visual Studio verfügt über das neue Feature „Visuelle Live-Struktur“. Sie können es während des Debuggens verwenden, um den Zustand der visuellen Struktur Ihrer App schnell zu erkennen und zu entdecken, wie Eigenschaften festgelegt wurden. Außerdem können Sie Eigenschaftswerte ändern, während die App ausgeführt wird. Somit können Sie experimentieren und optimieren, ohne erneut starten zu müssen.
Ablaufprotokollierung | [TraceLogging](https://docs.microsoft.com/windows/desktop/tracelogging/trace-logging-portal) ist eine neue Ereignisablaufverfolgungs-API für Benutzermodus-Apps und Kernelmodustreiber. Sie basiert auf der [Ereignisablaufverfolgung für Windows](https://docs.microsoft.com/windows/desktop/ETW/event-tracing-portal) (ETW). Diese API bietet eine vereinfachte Möglichkeit, Code zu instrumentieren und strukturierte Daten mit Ereignissen einzubeziehen, ohne dass eine separate Manifest-XML-Datei für die Instrumentierung erforderlich ist. TraceLogging-APIs für WinRT, .NET und C/C++ sind für verschiedene Entwicklerzielgruppen verfügbar.

## <a name="user-experience"></a>Benutzererfahrung

Feature | Beschreibung
 :---- | :----
Spracherkennung | Die universelle Windows-Plattform unterstützt jetzt die kontinuierliche Spracherkennung für Diktierszenarien mit langer Aufnahmezeit. In den Dokumenten zur Sprachinteraktion erfahren Sie, wie das kontinuierliche Diktieren ermöglicht wird.
Drag & Drop-Funktionen zwischen verschiedenen Anwendungsplattformen | Die neuen [Windows.ApplicationModel.DataTransfer.DragDrop](https://docs.microsoft.com/uwp/api/windows.applicationmodel.datatransfer.dragdrop)-Namespaces stellen den universellen Windows-Apps Drag & Drop-Funktionen zur Verfügung. Früher waren mit universellen Windows-Apps keine gängigen Drag & Drop-Szenarien für Desktopprogramme möglich, wie etwa das Ziehen eines Dokuments aus einem Ordner in eine Outlook-E-Mail, um es anzuhängen. Mit diesen neuen APIs kann Ihre App Benutzern das einfache Verschieben von Daten zwischen verschiedenen universellen Windows-Apps und dem Desktop ermöglichen. <br /><br />Zur Unterstützung von Drag & Drop zwischen Apps wurden diese neuen APIs zu XAML hinzugefügt: [ListViewBase.DragItemsCompleted](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.dragitemscompleted); <br />UIElement: [CanDrag](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.candrag), [DragStarting](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.dragstarting), [StartDragAsync](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.startdragasync), [DropCompleted](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.dropcompleted);  <br />[DragOperationDeferral](https://docs.microsoft.com/uwp/api/windows.ui.xaml.dragoperationdeferral), [DragUI](https://docs.microsoft.com/uwp/api/windows.ui.xaml.dragui), [DragUIOverride](https://docs.microsoft.com/uwp/api/windows.ui.xaml.draguioverride); <br />DragEventArgs: [AcceptedOperation](https://docs.microsoft.com/uwp/api/windows.ui.xaml.drageventargs.acceptedoperation), [DataView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.drageventargs.dataview), [DragUIOverride](https://docs.microsoft.com/uwp/api/windows.ui.xaml.drageventargs.draguioverride), [GetDeferral](https://docs.microsoft.com/uwp/api/windows.ui.xaml.drageventargs.getdeferral), [Modifiers](https://docs.microsoft.com/uwp/api/windows.ui.xaml.drageventargs.modifiers); <br />[DragItemsCompletedEventArgs](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.dragitemscompletedeventargs), [DropCompletedEventArgs](https://docs.microsoft.com/uwp/api/windows.ui.xaml.dropcompletedeventargs), [DragStartingEventArgs](https://docs.microsoft.com/uwp/api/windows.ui.xaml.dragstartingeventargs)
Benutzerdefinierte Titelleisten | Für UWP-Apps für die Desktop-Gerätefamilie können Sie nun die Klasse [ApplicationViewTitleBar](https://docs.microsoft.com/uwp/api/windows.ui.viewmanagement.applicationviewtitlebar) mit der Eigenschaft [ApplicationView.TitleBar](https://docs.microsoft.com/uwp/api/windows.ui.viewmanagement.applicationview.titlebar) und der Methode [Window.SetTitleBar](https://docs.microsoft.com/uwp/api/windows.ui.viewmanagement.applicationview.titlebar) verwenden, um den Inhalt der standardmäßigen Windows-Titelleiste durch Ihren eigenen benutzerdefinierten XAML-Inhalt zu ersetzen. Ihr XAML wird als "System Chrome", behandelt, damit Windows die Eingabeereignisse anstelle Ihrer App behandelt. Das bedeutet, dass der Benutzer das Fenster weiterhin ziehen und dessen Größe anpassen kann – und zwar auch dann, wenn er auf den Inhalt Ihrer benutzerdefinierten Titelleiste klickt.

## <a name="web"></a>Web

Feature | Beschreibung
 :---- | :----
Microsoft Edge | Microsoft Edge ist der neue, für Windows 10 entwickelte Standardbrowser. Weitere Informationen und eine Übersicht über die Entwicklerfeatures und -standards in Microsoft Edge (einschließlich der neuesten JavaScript-Funktionen) finden Sie im [Microsoft Edge-Entwicklerhandbuch](https://developer.microsoft.com/microsoft-edge/platform/documentation/dev-guide).
WebView-Browsen | Das [WebView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview)-Steuerelement verwendet die gleiche Renderingengine wie der neue Microsoft Edge-Browser. Dadurch wird der genaueste standardkonforme HTML-Renderingmodus zur Verfügung gestellt.
Hintergrundthread-WebView | Sie können einen [WebView.ExecutionMode](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.executionmode) angeben, um die Verarbeitung und Anzeige von Webinhalten auf einem separaten Hintergrundthread zu aktivieren. Dies kann die Leistung bei bestimmten spezifischen Szenarien verbessern.
WebView.UnsupportedUriSchemeIdentified-Ereignis | Mit dem neuen Ereignis [WebView.UnsupportedUriSchemeIdentified](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.unsupportedurischemeidentified) können Sie entscheiden, wie Ihre App ein nicht unterstütztes URI-Schema verwenden soll. Sie können dieses Ereignis behandeln, damit Ihre App eine benutzerdefinierte Behandlung von nicht unterstützten URI-Schemas bereitstellen kann. Das HTML-WebView-Steuerelement finden Sie unter dem Ereignis [MSWebViewUnsupportedUriSchemeIdentified](https://docs.microsoft.com/previous-versions/windows/apps/dn803906(v=win.10)).
WebView.NewWindowRequested-Ereignis | Das neue Ereignis [WebView.NewWindowRequested](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.newwindowrequested) ermöglicht Ihnen eine Antwort, wenn ein Skript in eine Webansicht ein neues Browserfenster anfordert. Das HTML-WebView-Steuerelement finden Sie unter dem Ereignis [MSWebViewNewWindowRequested](https://docs.microsoft.com/microsoft-edge/webview).
WebView.PermissionRequested-Ereignis | Mit dem neuen Ereignis [WebView.PermissionRequested](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.permissionrequested) können WebView-Inhalte die umfassenden neuen HTML5-APIs nutzen, die spezielle Erlaubnis des Benutzers wie Geolocation erfordern. Das HTML-WebView-Steuerelement finden Sie unter dem Ereignis [MSWebViewPermissionRequested](https://docs.microsoft.com/previous-versions/windows/apps/dn806030(v=win.10)).
WebView.UnviewableContentIdentified-Ereignis | Mit dem neuen Ereignis [WebView.UnviewableContentIdentified](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.unviewablecontentidentified) können Sie darauf reagieren, wenn in der Webansicht webfremde Inhalte wie etwa eine PDF-Datei oder ein Office-Dokument aufgerufen werden. Die HTML-WebView-Steuerelemente finden Sie unter dem Ereignis [MSWebViewUnviewableContentIdentified](https://docs.microsoft.com/microsoft-edge/webview).
WebView.AddWebAllowedObject-Methode | Sie können die neue Methode [WebView.AddWebAllowedObject](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.addweballowedobject) aufrufen, um ein WinRT-Objekt in ein XAML-WebView einzufügen, um dann ihre Funktionen über vertrauenswürdigen JavaScript aufzurufen, die in dieser WebView gehostet sind. Beispielsweise kann Webinhalt Systembenachrichtigungen anzeigen, indem es eine Anforderung stellt, dass dessen übergeordneter App-Aufruf [ToastNotificationManager](https://docs.microsoft.com/uwp/api/windows.ui.notifications.toastnotificationmanager) WinRT-API aufruft. Das HTML-WebView-Steuerelement finden Sie unter der Methode [addWebAllowedObject](https://docs.microsoft.com/microsoft-edge/webview).
WebView.ClearTemporaryWebDataAsync-Methode | Wenn ein Benutzer mit Webinhalten innerhalb einer XAML-WebView interagiert, führt das WebView-Steuerelement, basierend auf der Sitzung dieses Benutzers, eine Zwischenspeicherung der Daten durch. Rufen Sie die neue Methode [ClearTemporaryWebDataAsync](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.cleartemporarywebdataasync) auf, um diesen Cache zu löschen. Beispielsweise können Sie den Cache löschen, wenn sich ein Benutzer von der App abmeldet, damit ein anderer Benutzer nicht auf die Daten aus der vorherigen Sitzung zugreifen kann.
