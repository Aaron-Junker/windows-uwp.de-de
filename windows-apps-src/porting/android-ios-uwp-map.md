#Windows-Apps-Konzeptzuordnung für Android- und iOS-Entwickler

Wenn Sie Entwickler mit Android- oder iOS-Kenntnissen sind und/oder über den entsprechenden Code verfügen und zu Windows 10 und zur universellen Windows-Plattform (UWP) wechseln möchten, bietet Ihnen dieser Artikel alle Informationen, die Sie für die Zuordnung der Plattformfeatures – und Ihrer Kenntnisse – zwischen den drei Plattformen benötigen.

Siehe auch die Portierungsinformationen in [Wechsel von iOS zu UWP](ios-to-uwp-root.md).

## Benutzeroberfläche

|  **Allgemeines Konzept** | **Android** | **iOS** | **Windows 10 UWP** |
|  ------ | ------ | ------ | ------ |
|  **Entwurfssprache.** Eine Reihe von Konventionen für das Aussehen und Verhalten von Apps auf der Plattform. | Die Richtlinien von **Material Design für Android** bieten eine visuelle Sprache für Android-Designer und -Entwickler. | Die **Richtlinien für Eingabegeräte** bieten Empfehlungen für iOS-Designer und -Entwickler. | Der Artikel zum [**Entwerfen einer UWP-App-Benutzeroberfläche für Windows**](https://dev.windows.com/design) zeigt Ihnen, wie Sie eine App erstellen, die auf allen Windows 10-Geräten fantastisch aussieht. Dort finden Sie Grundlagen zum Benutzeroberflächenentwurf, Techniken für reaktionsfähiges Design und eine umfassende Liste ausführlicher Richtlinien.<br/> |
|  **Markupsprache für die Benutzeroberfläche.** Eine Markupsprache, mit der die Benutzeroberfläche und ihre Komponenten gerendert und beschrieben werden. Jede Plattform bietet einen Editor für die visuelle Bearbeitung und Markupbearbeitung.<br/> | **XML-Layouts**, mit **Android Studio** oder **Eclipse** bearbeitet. | **XIB** und **Storyboards**, mit **Interface Builder** in Xcode bearbeitet. | **[XAML](https://msdn.microsoft.com/library/windows/apps/xaml/mt185595.aspx)**, mit **[Microsoft Visual Studio](https://www.visualstudio.com/)** und **[Blend für Visual Studio](https://msdn.microsoft.com/library/jj171012.aspx)** bearbeitet.<br/><br/>[XAML-Plattform](https://msdn.microsoft.com/library/windows/apps/xaml/mt228259.aspx)<br/><br/>[Erstellen einer Benutzeroberfläche mit XAML](https://msdn.microsoft.com/library/windows/apps/xaml/mt228349.aspx)<br/><br/>[Definieren von Layouts mit XAML](https://msdn.microsoft.com/library/windows/apps/xaml/mt228350.aspx) |
|  **Integrierte Steuerelemente der Benutzeroberfläche.** Von der Plattform bereitgestellte wiederverwendbare UI-Elemente, z. B. Schaltflächen, Listensteuerelemente und Textsteuerelemente. | Vordefinierte **Ansichtsklassen** und **Ansichtsgruppenklassen**, die als Widgets, Layouts, Textfelder, Container, Datums- und Uhrzeitsteuerelemente und Expertensteuerelemente bezeichnet werden. | **Ansichten** und **Steuerelemente** in der Xcode-Objektbibliothek und im UIKit-Benutzeroberflächenkatalog. Ansichten umfassen Bildansichten, Auswahlansichten und Bildlaufansichten. Steuerelemente umfassen Schaltflächen, Datumsauswahl und Textfelder. | Die XAML-Plattform bietet Ihnen einen reichhaltigen Satz **integrierter Steuerelemente**, z. B. Schaltflächen, Listensteuerelemente, Panels, Textsteuerelemente, Befehlsleisten, Auswahl, Medien und Freihandeingabe.<br/><br/>[Hinzufügen von Steuerelementen und Verarbeiten von Ereignissen](https://msdn.microsoft.com/library/windows/apps/xaml/mt228345.aspx) |
|  **Steuern der Ereignisbehandlung.** Definieren der Logik, die ausgeführt wird, wenn in UI-Steuerelementen Ereignisse ausgelöst werden. | **Ereignishandler** und **Ereignislistener** werden in XML oder programmgesteuert hinzugefügt. | Steuerelemente senden **Action**-Meldungen an **Ziele**. | Sie können Methoden zum Behandeln der Ereignisse eines XAML-Steuerelements in einer **CodeBehind-Datei**, die der XAML-Seite zugeordnet ist, definieren. **Ereignishandler** werden immer in Code geschrieben. Sie können jedoch diese Handler im XAML-Markup oder im Code mit Ereignissen verbinden.<br/><br/>[Hinzufügen von Steuerelementen und Verarbeiten von Ereignissen](https://msdn.microsoft.com/library/windows/apps/xaml/mt228345.aspx)<br/><br/>[Übersicht über Ereignisse und Routingereignisse](https://msdn.microsoft.com/library/windows/apps/xaml/mt185584.aspx) |
|  **Datenbindung.** Ein Softwaredesignmuster, das der App-UI das Rendern von Daten und optional das Synchronisieren mit diesen Daten ermöglicht.  | Es wird eine **Datenbindungsbibliothek** bereitgestellt, bislang jedoch nur als Betaversion. | In iOS ist kein integriertes Bindungssystem vorhanden. **Key-Value Observing** kann als Grundlage für die Datenbindung verwendet werden, entweder mithilfe einer Drittanbieterbibliothek oder durch das Schreiben von zusätzlichem Code. Steuerelemente verwenden zum Abrufen von Daten Delegate/Rückrufe. | Die **Datenbindung** erfolgt durch die UWP-Plattform. Mit der **[{x:Bind}](https://msdn.microsoft.com/library/windows/apps/mt204783.aspx)**-Markuperweiterung nutzen Sie Bindung mit hoher Leistung, während Ihnen die **[{Binding}](https://msdn.microsoft.com/library/windows/apps/mt204782.aspx)**-Markuperweiterung eine größere Anzahl von Features bietet. Sie können die Bindung so konfigurieren, dass auf der Benutzeroberfläche mithilfe von **unidirektionaler Bindung** Werte aus einer Datenquelle angezeigt werden oder dass mithilfe von **bidirektionaler Bindung** diese Werte außerdem beobachtet werden und die Benutzeroberfläche aktualisiert wird, wenn sie sich ändern.<br/><br/>[Datenbindung](https://msdn.microsoft.com/library/windows/apps/mt210947.aspx) |
|  **Benutzeroberflächenautomatisierung.** Der programmgesteuerte Zugriff auf UI-Elemente ermöglicht den Zugriff auf Apps durch Hilfstechnologieprodukte und die Interaktion von automatisierten Testskripts mit der Benutzeroberfläche. | **Beschriftungen**, **contentDescription**- und **hint**-Werte erleichtern die automatisierte Suche von UI-Elementen. Android Studio ermöglicht Ihnen mit den Testumgebungen **UI Automator** und **Espresso** das Schreiben von UI-Tests. | Mit dem **Automation-Instrument** können Sie automatisierte UI-Testskripts schreiben, die mithilfe der **Accessibility**-Einstellungen Elemente identifizieren oder die die Position des Elements in der **Elementhierarchie** ermitteln. | Die **[Benutzeroberflächenautomatisierung](https://msdn.microsoft.com/library/windows/apps/ee684076.aspx)** bietet Ihnen unmittelbaren programmgesteuerten Zugriff auf integrierte UI-Elemente in UWP.<br/>**[Benutzerdefinierte Automatisierungspeers](https://msdn.microsoft.com/library/windows/apps/mt297667.aspx)** ermöglichen Ihnen die Bereitstellung von Automatisierungsunterstützung für eigene benutzerdefinierte UI-Klassen. Das **[Projekt mit Tests der codierten UI](https://msdn.microsoft.com/library/dd286726.aspx#VerifyingCodeUsingCUITCreate)** in Visual Studio ermöglicht Ihnen das Durchführen automatisierter Tests der gesamte Anwendung über die UI oder das Testen der isolierten UI. |
|  **Ändern der Darstellung eines Steuerelements.** Bearbeiten von Größe, Farbe und anderen Attributen. | Steuerelemente verfügen über **Eigenschaften**, die mithilfe des Entwicklungstools, im XML-Markup oder programmgesteuert bearbeitet werden können. | Steuerelemente verfügen über **Attribute**, die Sie mit dem **Attributes Inspector** in Interface Builder oder programmgesteuert bearbeiten können. | Sie können mit Visual Studio und Blend für Visual Studio die **Eigenschaften** von Steuerelementen im XAML-Markup oder programmgesteuert bearbeiten.<br/><br/>[Hinzufügen von Steuerelementen und Verarbeiten von Ereignissen](https://msdn.microsoft.com/library/windows/apps/xaml/mt228345.aspx) |
|  **Wiederverwendbare visuelle Stile.** Anwenden visueller Änderungen in einem wiederverwendbaren Format auf eine Reihe von Steuerelementen. | **XML Styles** sind Gruppen von Eigenschaften, die auf ein oder mehrere Steuerelemente angewendet werden. | In iOS wird die Wiederverwendung visueller Stile nicht standardmäßig unterstützt, jedoch ermöglicht das UIAppearance-Protokoll die gemeinsame Nutzung allgemeiner Attribute durch mehrere Steuerelemente. | Sie können wiederverwendbare **[Stile](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.style.aspx)** erstellen, die auf mehrere Steuerelemente angewendet und für die einfache Wiederverwendung in einem **[ResourceDictionary](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.resourcedictionary.aspx)** gespeichert werden.<br/><br/>[Schnellstart: Entwerfen von Steuerelementen](https://msdn.microsoft.com/library/windows/apps/xaml/hh465381.aspx) |
|  **Bearbeiten der visuellen Struktur von Steuerelementen.** Sie können die visuelle Struktur eines Steuerelements umfassender anpassen, als lediglich Eigenschaften oder Attribute zu ändern, z. B. den Kontrollkästchentext unter das Kontrollkästchen verschieben. | In Android gibt es keine einfache Methode zum Bearbeiten der visuellen Struktur von Steuerelementen. | In iOS gibt es keine einfache Methode zum Bearbeiten der visuellen Struktur von Steuerelementen. | Um die visuelle Struktur eines Steuerelements anzupassen, können Sie seine **[Steuerelementvorlage](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.controltemplate.aspx)** im XAML-Markup kopieren und bearbeiten.<br/><br/>[Schnellstart: Steuerelementvorlagen](https://msdn.microsoft.com/library/windows/apps/xaml/hh465374.aspx)  |
|  **Integrierte Touchgesten.** Bereitstellen von angepasster Touchunterstützung durch die Behandlung allgemeiner Gestenereignisse, z. B. Tippen und Doppeltippen in Ansichten und Steuerelementen. | **GestureDetectors** erkennen allgemeine Touchgesten, einschließlich Bildlauf, langes Drücken, Tippen, Doppeltippen und schnelles Wischen. | Das UIKit-Framework bietet integrierte **Gestenerkennungen**, die Touchgesten, einschließlich Tippen, Zusammendrücken, Schwenken, Wischen, Drehen und langes Drücken, erkennen. | Mit **UI-Elementen** können Sie **statische Gestenereignisse**, z. B. Tippen, Doppeltippen, Rechtstippen und Halten, sowie **Manipulationsgestenereignisse**, z. B. Ziehen, Wischen, Drehen, Zusammendrücken und Aufziehen, behandeln. Gestenereignisse sind **Routingereignisse** und können von übergeordneten Objekten, die das untergeordnete UIElement enthalten, behandelt werden.<br/><br/>[Interaktionen per Toucheingabe](https://msdn.microsoft.com/library/windows/apps/mt185617.aspx)<br/><br/>[Benutzerdefinierte Benutzerinteraktionen – Gesten, Manipulationen und Interaktionen](https://msdn.microsoft.com/library/windows/apps/mt185599.aspx#gestures__manipulations__and_interactions) |

## Navigations- und App-Struktur

|  **Allgemeines Konzept** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Layouts.** Das Layout definiert die Struktur der Benutzeroberfläche. | Das Layout besteht aus **Ansichtsgruppen**, z. B. **LinearLayout** und **RelativeLayout**, in denen andere Ansichtsgruppen oder Ansichten geschachtelt werden können. | Das Layout besteht aus einem **UIViewController**, der **UIViews** enthält, die geschachtelt werden können.  | XAML bietet ein flexibles Layoutsystem, das aus **Layoutpanel-Klassen**, z. B. **[Canvas](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.canvas.aspx)**, **[Grid](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.grid.aspx)**, **[RelativePanel](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.relativepanel.aspx)** und **[StackPanel](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.stackpanel.aspx)**, für statische und dynamische Layouts besteht. **[Eigenschaften](https://msdn.microsoft.com/library/ms171352.aspx)** dienen zum Steuern der Größe und Position der Elemente.<br/><br/>[Definieren von Layouts mit XAML](https://msdn.microsoft.com/library/windows/apps/mt228350.aspx)<br/> |
|  **Peer-to-Peer-Navigation.** Bereitstellen von Methoden für den Benutzer, um zwischen Seiten auf der gleichen Hierarchieebene zu navigieren. | **Tabs**, **Wischbewegungen** und **Navigation Drawers** stellen **laterale Navigation** bereit. | **TabBarController**, **SplitViewController** und **PageViewController** ermöglichen die Navigation zwischen Ansichten auf gleicher Hierarchieebene. | Sie können mit **[Registerkarten/Pivots](https://msdn.microsoft.com/library/windows/apps/dn997788.aspx)** eine dauerhafte Liste von Links/Registerkarten über dem Inhalt anzeigen. Mit **[Navigationsbereich/geteilter Ansicht](https://msdn.microsoft.com/library/windows/apps/dn997787.aspx)** können Sie neben dem Inhalt eine Liste von Links anzeigen.<br/><br/>[Navigation](https://msdn.microsoft.com/library/windows/apps/mt187344.aspx)<br/><br/>[Peer-zu-Peer-Navigation zwischen zwei Seiten](https://msdn.microsoft.com/library/windows/apps/mt465735.aspx) |
|  **Hierarchische Navigation.** Navigieren zwischen über- und untergeordneten Seiten einer Hierarchie. | **Listen** und **Rasterlisten**, **Schaltflächen** und weitere Steuerelemente bieten **absteigende Navigation**, wenn sie mit **Intents** zum Laden weiterer **Activities** verwendet werden. | **Navigation Controller** ermöglichen Benutzern die Navigation zwischen den Ebenen einer Hierarchie. | **
							Mit [Hubs](https://msdn.microsoft.com/library/windows/apps/dn449149.aspx)** kann für den Benutzer eine Vorschau von Inhalten angezeigt werden, die ausgewählt werden können, um zwischen untergeordneten Seiten zu navigieren. **
							Mit [Master/Details](https://msdn.microsoft.com/library/windows/apps/dn997765.aspx)** kann der Benutzer aus einer Liste von Elementübersichten auswählen, die neben dem entsprechenden Detailabschnitt angezeigt werden.<br/><br/>[Navigation](https://msdn.microsoft.com/library/windows/apps/mt187344.aspx) |
|  **Navigation per Schaltfläche „Zurück“.** Rückwärtsnavigation in einer Anwendung. | Die **Zurück**- und **Nach-oben**-Schaltfläche auf der Aktionsleiste bieten **aufsteigende** und **temporale** Navigation mithilfe des **Zurück-Stapels**. | Dem **Navigation Controller** kann eine Zurück-Schaltfläche hinzugefügt werden.<br/> | Mit der **[BackStack-Eigenschaft](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.frame.backstack.aspx)**, die dem Benutzer das Durchlaufen des **Navigationsverlaufs** ermöglicht, lässt sich das Betätigen der Zurück-Schaltfläche bzw. Zurück-Taste einfach behandeln.<br/><br/>[Navigation per Schaltfläche „Zurück“](https://msdn.microsoft.com/library/windows/apps/mt465734.aspx) |
|  **Begrüßungsbildschirm.** Das Anzeigen eines Bilds beim Starten der App, hauptsächlich für Branding verwendet. | Begrüßungsbildschirme werden nicht standardmäßig bereitgestellt und werden durch Bearbeiten des ersten **Designhintergrunds** für Aktivitäten implementiert. | Apps müssen über ein **statisches Startbild** oder eine **XIB-/Storyboard-Startdatei** verfügen. | Sie erstellen einen Begrüßungsbildschirm mithilfe eines **Bilds** und farbigen Hintergrunds. [Die Anzeige eines Begrüßungsbildschirms kann verlängert werden](https://msdn.microsoft.com/library/windows/apps/mt187309.aspx).<br/><br/>[Hinzufügen eines Begrüßungsbildschirms](https://msdn.microsoft.com/library/windows/apps/mt187306.aspx)<br/><br/>[Richtlinien für Begrüßungsbildschirme](https://msdn.microsoft.com/library/windows/apps/hh465338.aspx) |

## Benutzerdefinierte Eingaben

|  **Allgemeines Konzept** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Spracheingabe.** Spracherkennung für die Spracheingabe und zusätzliche Sprachfunktionen. | Die Spracheingabe kann durch jede App bereitgestellt werden, die einen **RecognizerIntent** implementiert, z. B. die **Google-Sprachsuche**. Die **SpeechRecognizer**-Klasse ermöglicht Apps die Verwendung der Spracherkennungs-API von Google. | Es ist keine integrierte Spracherkennungs- oder Spracheingabe-API vorhanden. | Sie können für die Interaktion mit der App im Vordergrund die **[Spracherkennungs](https://msdn.microsoft.com/library/windows/apps/mt185615.aspx)**-API verwenden. Mithilfe von sprachbasierten **[Cortana-Interaktionen](https://msdn.microsoft.com/library/windows/apps/mt185598.aspx)** können Sie Apps im Vordergrund oder Hintergrund starten und mit Hintergrund-Apps interagieren.<br/><br/>[Sprachinteraktionen](https://msdn.microsoft.com/library/windows/apps/mt185614.aspx) |
|  **Benutzerdefinierte Benutzereingaben.** Behandeln von Eingaben per Tastatur, Maus, Stift und anderen Eingaben. | Die Unterstützung von Interaktionen umfasst **Berührung**, **Touchpad**, **Eingabestift**, **Maus** und **Tastatur**. Bewegungen und Eingaben werden auf die gleiche Weise wie Berührung gemeldet, es lassen sich jedoch weitere Informationen über das **Eingabegerät** ermitteln. | Es wird Unterstützung für **Berührung**, **Apple Pencil** und **Hardwaretastaturen** bereitgestellt. | Sie finden Unterstützung für eine Vielzahl von Interaktionen, einschließlich **[Berührung](https://msdn.microsoft.com/library/windows/apps/mt185617.aspx)**, **[Touchpad](https://msdn.microsoft.com/library/windows/apps/mt187313.aspx)**, **[Zeichen-/Eingabestift](https://msdn.microsoft.com/library/windows/apps/mt187311.aspx)** mit Freihandschrift, **[Maus](https://msdn.microsoft.com/library/windows/apps/mt187308.aspx)** und **[Tastatur](https://msdn.microsoft.com/library/windows/apps/mt185607.aspx)**. Ihre Apps können die Daten behandeln, ohne Informationen über das verwendete Eingabegerät zu benötigen, und bei Bedarf kann auf Daten von Rohdateneingabegeräten zugegriffen werden.<br/><br/>[Behandeln von Zeigereingaben](https://msdn.microsoft.com/library/windows/apps/mt404610.aspx)<br/><br/>[Benutzerdefinierte Benutzerinteraktionen](https://msdn.microsoft.com/library/windows/apps/mt185599.aspx) |

## Daten

|  **Allgemeines Konzept** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Lokale App-Daten.** Lokales Speichern von Einstellungen und Dateien für die App. | Lokale Dateien können mit **openFileOutput** und **openFileInput** gespeichert werden. Auf die Einstellungen in einer **SharedPreferences-Datei** kann mithilfe von **getSharedPreferences** zugegriffen werden. | Lokale Dateien können im Verzeichnis **Application Support** gespeichert werden, auf das über die **NSFileManager**-Klasse zugegriffen wird. Der Zugriff auf die Einstellungen in **Preference**-Dateien erfolgt über die **NSUserDefaults**-Klasse. | Mit den **[Windows.Storage](https://msdn.microsoft.com/library/windows/apps/xaml/br230562.aspx)**-Klassen werden lokale Daten auf einheitliche Weise gespeichert. Einstellungen werden als **[ApplicationDataContainer](https://msdn.microsoft.com/library/windows/apps/xaml/windows.storage.applicationdatacontainer.aspx)**-Objekt gespeichert, auf das mit der **[ApplicationData.LocalSettings](https://msdn.microsoft.com/library/windows/apps/xaml/windows.storage.applicationdata.localsettings.aspx)**-Eigenschaft zugegriffen wird. Dateien werden in einem **[StorageFolder](https://msdn.microsoft.com/library/windows/apps/windows.storage.storagefolder.aspx)**-Objekt gespeichert, auf das mit der **[ApplicationData.LocalFolder](https://msdn.microsoft.com/library/windows/apps/xaml/windows.storage.applicationdata.localfolder.aspx)**-Eigenschaft zugegriffen wird.<br/><br/>[Speichern und Abrufen von Einstellungen und anderen App-Daten](https://msdn.microsoft.com/library/windows/apps/xaml/mt299098.aspx) |
|  **Lokaler Datenbankspeicher.** Speichern von App-Daten in einer relationalen Datenbank, ggf. mit objektrelationalem Mapping (ORM). | Die **SQLite**-Datenbank wird bereitgestellt. ORM ist nicht integriert. SQL-Abfragen werden mit der **SQLiteDatabase**-Klasse ausgeführt. | Die **SQLite**-Datenbank wird bereitgestellt. Das integrierte Objektdiagrammframework **CoreData** kann mit SQLite verwendet werden und mit ORM vergleichbare Funktionalität bereitstellen. | Sie können Daten mithilfe **SQLite** speichern. **[Entity Framework](https://msdn.microsoft.com/library/windows/apps/xaml/mt592863.aspx)** ist ein integriertes ORM, mit dem die Notwendigkeit entfällt, umfangreichen Datenzugriffscode zu schreiben, und mit dem Sie die Datenbank einfach abfragen können, ohne SQL zu schreiben. Sie können SQL-Abfragen direkt mit der [SQLite-Bibliothek](https://msdn.microsoft.com/library/windows/apps/xaml/mt592864.aspx) ausführen.<br/><br/>[Datenzugriff](https://msdn.microsoft.com/library/windows/apps/xaml/mt592862.aspx) |
|  **HTTP-Bibliotheken für den Zugriff auf REST-APIs.** Integrierte Bibliotheken, die Ihnen die Kommunikation mit Webdiensten und Webservern per HTTP(S) ermöglichen.<br/> | HTTP-Bibliotheken **HttpURLConnection** und **Volley**. | **NSURLSession**, **NSURLConnection** und **NSURLDownload**. | Die integrierte **[HttpClient](https://msdn.microsoft.com/library/windows/apps/xaml/windows.web.http.httpclient)**-API bietet Ihnen Zugriff auf allgemeine HTTP-Funktionen, z. B. GET, DELETE, PUT, POST, allgemeine Authentifizierungsmuster, SSL, Cookies und Statusinformationen. |
|  **Cloudsicherungsdienste.** Von der Plattform bereitgestellte Sicherungsdienste für App-Daten.  | Mit dem **Backup Manager** von Android werden Anwendungsdaten im **Android Sicherungsdienst** von Google gesichert.  | Das **iCloud-Backup** kann vom Benutzer zum Durchführen der Sicherungen, einschließlich der App-Daten, konfiguriert werden. Apps, die mit iCloud kompatible **Core Data**, den **iCloud-Schlüssel-Wert-Speicher** und die **Dokumentenspeicherung in iCloud** verwenden. | Alle App-Daten, die Sie mithilfe der APIs für das Roaming von **[ApplicationData](https://msdn.microsoft.com/library/windows/apps/windows.storage.applicationdata.aspx)** (einschließlich **[RoamingFolder](https://msdn.microsoft.com/library/windows/apps/windows.storage.applicationdata.roamingfolder.aspx)** und [**RoamingSettings**](https://msdn.microsoft.com/library/windows/apps/windows.storage.applicationdata.roamingsettings.aspx)) speichern, werden automatisch mit der Cloud und anschließend auch mit den anderen Geräten des Benutzers synchronisiert. Die Synchronisierung erfolgt über das Microsoft-Konto des Benutzers.<br/><br/>[Richtlinien für das Roaming von App-Daten](https://msdn.microsoft.com/library/windows/apps/hh465094.aspx) |
|  **HTTP-Dateidownloads.** Herunterladen von kleinen und großen Dateien per HTTP. | Für den Download per HTTP und FTP werden **URLConnection** und **HTTPURLConnection** verwendet. Für den Download im Hintergrund kann auch der **Download-Manager** des Systems verwendet werden. | Für den Download von Dateien per HTTP und FTP können **NSURLSession** und **NSURLConnection** verwendet werden. | Mit der **[Hintergrundübertragungs-API](https://msdn.microsoft.com/library/windows/apps/windows.networking.backgroundtransfer.aspx)** können Sie Dateien zuverlässig per HTTP(S) und FTP übertragen und dabei das Anhalten der App sowie Verbindungsunterbrechungen berücksichtigen und Anpassungen entsprechend Konnektivität und Akkulaufzeit vornehmen. Sie können auch die **[HttpClient](https://msdn.microsoft.com/library/windows/apps/windows.web.http.httpclient.aspx)**-Klasse verwenden, die sich besonders für kleinere Dateien eignet.<br/><br/>[Welche Netzwerktechnologie?](https://msdn.microsoft.com/library/windows/apps/mt280235.aspx)<br/><br/>[Hintergrundübertragungen](https://msdn.microsoft.com/library/windows/apps/mt280377.aspx) |
|  **Sockets.** Erstellen von UDP-Datagrammsockets und TCP-Sockets als Low-Level-Schnittstelle für die Kommunikation mit anderen Geräten unter Verwendung des eigenen Protokolls. | Die **Socket**-Klasse stellt TCP-Sockets bereit, und die **DatagramSocket**-Klasse stellt einen UDP-Socket bereit. | **NSStream** und **CFStream** stellen TCP-Sockets bereit, und **CFSocket** stellt UDP-Sockets bereit. | Sie können die **[DatagramSocket](https://msdn.microsoft.com/library/windows/apps/br241319)**-Klasse für die Kommunikation mit einem UDP-Datagrammsocket und die **[StreamSocket](https://msdn.microsoft.com/library/windows/apps/br226882)**-Klasse für die Kommunikation per TCP oder Bluetooth RFCOMM verwenden.<br/><br/>[Grundlagen zum Netzwerk](https://msdn.microsoft.com/library/windows/apps/mt280233.aspx)<br/><br/>[Welche Netzwerktechnologie?](https://msdn.microsoft.com/library/windows/apps/mt280235.aspx)<br/><br/>[Übersicht über Sockets](https://msdn.microsoft.com/library/windows/apps/mt280234.aspx) |
|  **WebSockets.** Bieten bidirektionale Kommunikation zwischen einem Client und einem Server und ermöglichen die Datenübertragung in Echtzeit. | In Android sind keine WebSockets-Bibliotheken integriert. | In iOS sind keine WebSockets-Bibliotheken integriert. | Sichere Verbindungen mit Servern, die WebSockets unterstützen, können mit der **[MessageWebSocket](https://msdn.microsoft.com/library/windows/apps/windows.networking.sockets.messagewebsocket.aspx)**-Klasse hergestellt werden, um kleinere Nachrichten mit Empfangsbestätigung zu senden, und mit **[StreamWebSocket](https://msdn.microsoft.com/library/windows/apps/windows.networking.sockets.streamwebsocket.aspx)**, um größere Binärdateien zu übertragen, die in Abschnitten gelesen werden können.<br/><br/>[Grundlagen zum Netzwerk](https://msdn.microsoft.com/library/windows/apps/mt280233.aspx)<br/><br/>[Welche Netzwerktechnologie?](https://msdn.microsoft.com/library/windows/apps/mt280235.aspx)<br/><br/>[Übersicht über WebSockets](https://msdn.microsoft.com/library/windows/apps/mt186447.aspx) |
|  **OAuth-Bibliotheken.** OAuth-Bibliotheken ermöglichen den Zugriff auf OAuth-Drittanbieter und jede in die Plattform integrierte Kontoverwaltung. | Es wird keine generische OAuth-Bibliothek bereitgestellt. Für die OAuth-Authentifizierung bei Google Play-Diensten wird die **GoogleAuthUtil**-Klasse bereitgestellt.<br/> | Es wird keine generische OAuth-Bibliothek bereitgestellt. Das **Accounts Framework** bietet Zugriff auf Benutzerkonten, die bereits auf dem Gerät gespeichert sind, z. B. Facebook und Twitter. | Mit dem **[Webauthentifizierungsbroker](https://msdn.microsoft.com/library/windows/apps/mt270196.aspx)** aus der generischen OAuth-Bibliothek können Sie eine Verbindung mit Identitätsanbieterdiensten von Drittanbietern herstellen. Die Benutzer können im **[Schließfach für Anmeldeinformationen](https://msdn.microsoft.com/library/windows/apps/mt270189.aspx)** ihre Anmeldeinformationen speichern und sie auf mehreren Geräten verwenden. Der **[Microsoft.Live](https://msdn.microsoft.com/library/windows/apps/dn896755.aspx)**-Namespace ermöglicht Ihnen den einfachen Zugriff auf das Live SDK-OAuth-Protokoll für den Zugriff auf Microsoft-Dienste.<br/><br/>[Authentifizierung und Benutzeridentität](https://msdn.microsoft.com/library/windows/apps/mt270184.aspx)<br/><br/>[Windows.Security.Authentication.Web-API-Dokumentation](https://msdn.microsoft.com/library/windows/apps/windows.security.authentication.web.aspx)<br/><br/>[WebAuthenticationBroker-Codebeispiel](https://github.com/Microsoft/Windows-universal-samples/tree/master/Samples/WebAuthenticationBroker) |

## Tools

|  **Allgemeines Konzept** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **IDE.** Das zum Erstellen der App verwendete Toolset. | **Android Studio** und **Eclipse**, wobei Google Entwicklern die Verwendung von Android Studio empfiehlt. | **Xcode** | **[Visual Studio](https://www.visualstudio.com/features/universal-windows-platform-vs.aspx)** und **[Blend für Visual Studio](https://msdn.microsoft.com/library/jj171012.aspx)** verfügen über alle Tools, die Sie zum Codieren, Entwerfen, Verbinden, Debuggen, Analysieren, Optimieren und Testen von UWP-Apps benötigen. Visual Studio bietet Ihnen außerdem **[Emulatoren](https://msdn.microsoft.com/library/windows/apps/mt188754.aspx)** für Windows 10-Geräte, sodass Sie Ihre App auf unterschiedlichen emulierten Geräten testen können.<br/><br/>[Downloads und Tools für UWP](https://dev.windows.com/downloads) |
|  **Codeorganisation.** Die grundlegende Ordnerstruktur einer App, häufig anhand einer anfänglichen Vorlage erstellt. | **AndroidManifest**-Datei, **java**-Ordner mit Quelldateien, **res**-Ordner mit Ressourcen, einschließlich Layouts und Werten, **Gradle**-Buildskripts in Android Studio und **Ant**-Buildskripts in Eclipse. | Quelldateien und **Supporting Files**, Datei **Info.plist**, **Main.storyboard** und **LaunchScreen.storyboard**. In **Objektbibliotheken** gespeicherte Images. | Die UWP-App enthält XAML- und Codedateien für die App mit den Namen „Example.xaml“ und „Example.xaml.cs“, verschiedene Images im Ordner **Assets**, eine Startseite, z. B. **MainPage.xaml** oder **MainPage.xaml.cs**, und ein Manifest.<br/><br/>[Erstellen der App „Hello, world“](https://msdn.microsoft.com/library/windows/apps/dn765018.aspx) |

## App-Lebenszyklus

|  **Allgemeines Konzept** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **App-Lebenszyklus.** Behandeln von Ereignissen beim Starten, Anhalten, Fortsetzen und Schließen der App, mit der Möglichkeit, den Anwendungszustand zu speichern/wiederherzustellen und weitere Aufgaben auszuführen. | Jede Aktivität verfügt über einen eigenen **Aktivitätslebenszyklus** mit Zuständen, z. B. **resumed**. **Lebenszyklusrückrufe**, z. B. **onResume**, werden in den **Aktivitätsklassen** implementiert. | Der **Anwendungslebenszyklus** weist Zustände, z. B. **suspended**, auf. Methoden, z. B. **applicationDidEnterBackground:**, werden im **appDelegate**-Objekt implementiert, um bei Zustandsänderungen Code auszuführen. | Die Anwendung weist die **App-Ausführungszustände** „NotRunning“, „Activated“, „Runningׅ“, „Suspending“, „Suspended“ und „Resuming“ auf.<br/><br/>Sie können die Methode „OnLaunched“, „OnActivated“, „Suspending“ oder „Resuming“ der **[Application-Klasse](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.application.aspx)** implementieren, um Code auszuführen, wenn sich der Zustand ändert.<br/><br/>[App-Lebenszyklus](https://msdn.microsoft.com/library/windows/apps/mt243287.aspx) |
|  **Hintergrundaufgaben.** Aufgaben, die Vorgänge im Hintergrund ausführen und weiterhin ausgeführt werden, wenn die App nicht mehr im Vordergrund ausgeführt wird. | Apps können **Dienste** starten, die Hintergrundvorgänge ausführen, wenn die App nicht mehr im Vordergrund ausgeführt wird. Dienste besitzen einen eigenen **Lebenszyklus** und werden im Manifest registriert. | Die **Ausführung im Hintergrund** ist nur für bestimmte Aufgabentypen zulässig.<br/><br/>Apps deklarieren **unterstützte Hintergrundaufgaben** in der Datei „Info.plist“ mithilfe der **UIBackgroundModes**.<br/><br/>Das System steuert, wann und wie lange Hintergrundaufgaben ausgeführt werden. | Sie können eine Hintergrundaufgabe erstellen, indem Sie die **[IBackgroundTask](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.background.ibackgroundtask.aspx)**-Schnittstelle implementieren und die Aufgabe im Anwendungsmanifest registrieren. Sie können festlegen, dass eine Aufgabe durch einen [**Timer**](https://msdn.microsoft.com/library/windows/apps/mt186458.aspx), [**Systemtrigger**](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.background.systemtriggertype.aspx) oder [**Wartungstrigger**](https://msdn.microsoft.com/library/windows/apps/mt185632.aspx) ausgelöst wird.<br/><br/>[Unterstützen Ihrer App mit Hintergrundaufgaben](https://msdn.microsoft.com/library/windows/apps/mt299103.aspx)<br/><br/>[Erstellen und Registrieren einer Hintergrundaufgabe](https://msdn.microsoft.com/library/windows/apps/mt299100.aspx)<br/><br/>[Richtlinien für Hintergrundaufgaben](https://msdn.microsoft.com/library/windows/apps/mt187310.aspx) |

## Leistung

|  **Allgemeines Konzept** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Bewährte Methoden zur Leistungssteigerung.** Richtlinien für das Erstellen von schnellen, dynamischen und akkuschonenden Apps mit kurzer Startzeit. | Android bietet das Schulungshandbuch **Best Practices for Performance** (Bewährte Methoden zur Leistungssteigerung). | iOS bietet das Dokument **Performance Overview** (Übersicht über die Leistung). | Sie können das ausführliche **[Handbuch zur Leistung](https://msdn.microsoft.com/library/windows/apps/mt270266.aspx)** lesen, das Abschnitte zu beispielsweise folgenden Themen enthält: Festlegen von Leistungszielen, Messen der Leistung, Speicherverwaltung, flüssige Animationen, effizienter Dateisystemzugriff sowie die verfügbaren Tools für Profilerstellung und Leistung. |
|  **Ansichtsoptimierung für eine reaktionsfähige Benutzeroberfläche.** Verbessern der Leistung durch Optimieren der Ansichten. | Das Optimieren der **Layouthierarchien** mit dem Tool Hierarchy Viewer, das **Wiederverwenden von Layouts** und das Laden von **Ansichten bei Bedarf** sind Verfahren, mit denen Sie die Reaktionsfähigkeit des UI-Threads erhalten und verhindern, dass ANR-Meldungen (**Application Not Responding**) ausgegeben werden.<br/> | Beheben von UI-Problemen mit **Offscreen-Rendering**, **Mischebenen** und **Rasterung** mithilfe des Tools **Core Animation**, um die Reaktionsfähigkeit des UI-Threads zu erhalten. | Sie können mit einigen einfachen Schritten das XAML-**Markup** und die XAML-**Layouts** **optimieren**. Dazu gehören das Reduzieren der Layoutstruktur, das Minimieren der Elementanzahl und das Minimieren der Überzeichnung. <br/><br/>[Aufrechterhalten der Reaktionsfähigkeit des UI-Threads](https://msdn.microsoft.com/library/windows/apps/mt185403.aspx)<br/><br/>[Optimieren Ihres XAML-Markups](https://msdn.microsoft.com/library/windows/apps/mt204779.aspx)<br/><br/>[Optimieren des XAML-Layouts](https://msdn.microsoft.com/library/windows/apps/mt404609.aspx) |
|  **Threading.** Verwenden von Threading zum Aufrechterhalten der **Reaktionsfähigkeit der Benutzeroberfläche** und **parallelen Ausführen mehrerer Aufgaben**. | Threading erfolgt mithilfe der Klassen **Runnable**, **Handler**, **ThreadPoolExecutor** und der abstrakten Klasse **AsyncTask**. | Threading erfolgt mithilfe von **NSThread**, **Grand Central Dispatch** und der abstrakten Klasse **NSOperation**. | Sie können mit Threads arbeiten, indem Sie mit **[RunAsync](https://msdn.microsoft.com/library/windows/apps/windows.system.threading.threadpool.runasync.aspx)** **Arbeitsaufgaben** an den **Threadpool** senden. Sie können mit **[CreateTimer](https://msdn.microsoft.com/library/windows/apps/br230590.aspx)** einen Timer zum Senden einer Arbeitsaufgabe verwenden und mit **[CreatePeriodicTimer](https://msdn.microsoft.com/library/windows/apps/br230589.aspx)** eine regelmäßige Arbeitsaufgabe erstellen.<br/><br/>[Senden einer Arbeitsaufgabe an den Threadpool](https://msdn.microsoft.com/library/windows/apps/mt187339.aspx)<br/><br/>[Senden einer Arbeitsaufgabe mithilfe eines Timers](https://msdn.microsoft.com/library/windows/apps/mt187341.aspx)<br/><br/>[Erstellen einer regelmäßigen Arbeitsaufgabe](https://msdn.microsoft.com/library/windows/apps/mt187338.aspx)<br/><br/>[Bewährte Methoden zum Verwenden des Threadpools](https://msdn.microsoft.com/library/windows/apps/mt187336.aspx) |
|  **Asynchrone Programmierung.** Vermeiden Sie komplexes Threading, indem Sie mit Mustern der asynchronen Programmierung die Reaktionsfähigkeit des UI-Threads aufrechterhalten.  | Zum Erstellen eigener asynchroner Klassen ist **die Verwendung von Threading erforderlich**. Einige integrierte Klassen sind asynchron. | Zum Erstellen eigener asynchroner Klassen ist **die Verwendung von Threading erforderlich**. Einige integrierte Klassen sind asynchron. | Sie können durch die Verwendung asynchroner Muster, z. B. mit **async** und **await** in C# und Visual Basic, vermeiden, dass der Hauptthread blockiert wird, wenn Sie eigene APIs erstellen. Sie können die integrierten asynchronen APIs verwenden, die mit dem Wort **Async** enden.<br/><br/>[Asynchrone Programmierung](https://msdn.microsoft.com/library/windows/apps/mt187335.aspx)<br/><br/>[Aufrufen asynchroner APIs in C# oder Visual Basic](https://msdn.microsoft.com/library/windows/apps/mt187337.aspx) |
|  **Optimierung der Listenansicht.** Integrierte Muster zum Optimieren von Datenlisten, die häufig eine geringe Leistung aufweisen, wenn große Mengen von Daten angezeigt werden müssen. | Das **ViewHolder**-Entwurfsmuster wird verwendet, um mehrfache Ansichtssuchvorgänge zu vermeiden, sodass Sie wiederverwendbare UI-Elemente verwenden können. | Die Leistung von **UITableView** kann mit einer Reihe von Optimierungen verbessert werden, es ist jedoch keine Optimierung integriert. | Sie können das [ListView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listview.aspx)- und das [GridView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.gridview.aspx)-Steuerelement verwenden. Diese bieten bereits **UI-Virtualisierung** für gleichmäßiges Schwenken und gleichmäßigen Bildlauf sowie schnelleres Starten. Sie können auch [IList](https://msdn.microsoft.com/library/windows/apps/system.collections.ilist.aspx) und [INotifyCollectionChanged](https://msdn.microsoft.com/library/windows/apps/system.collections.specialized.inotifycollectionchanged.aspx) in der Datenquelle implementieren, um **Datenvirtualisierung** bereitzustellen und die Leistung zusätzlich zu verbessern.<br/><br/>[Optimieren der ListView- und GridView-Benutzeroberfläche](https://msdn.microsoft.com/library/windows/apps/mt204776.aspx)<br/><br/>[Virtualisierung von ListView- und GridView-Daten](https://msdn.microsoft.com/library/windows/apps/mt574120.aspx) |

## Monetisierung

|  **Allgemeines Konzept** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **In-App-Käufe.** Plattformfeatures ermöglichen es den Benutzern, in Ihren Apps Käufe durchzuführen. | Google-Dienste bieten **In-App-Abrechnung**. Produkte werden der **Google Play Developer Console** hinzugefügt. In-App-Käufe werden mit der **Google Play Billing Library** implementiert. | Produkte werden **iTunes Connect** hinzugefügt. In-App-Käufe werden mit dem **StoreKit**-Framework implementiert.<br/><br/>Produkte werden mithilfe von **SKMutablePayment** und **SKPaymentQueue** gekauft. | Sie erstellen In-App-Produktkäufe für Ihre App, indem Sie [sie Ihrer App hinzufügen und an den Store übermitteln](https://msdn.microsoft.com/library/windows/apps/mt148551.aspx). <br/><br/>Sie definieren In-App-Käufe mit der **[CurrentApp-Klasse](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.currentapp.aspx)**. <br/><br/>Mit **[CurrentApp.RequestProductPurchaseAsync](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.currentapp.requestproductpurchaseasync.aspx)** zeigen Sie die Benutzeroberfläche an, auf der Kunden das Produkt kaufen können.<br/><br/>[Aktivieren von In-App-Produktkäufen](https://msdn.microsoft.com/library/windows/apps/mt219684.aspx) |
|  **In-App-Käufe von Verbrauchsartikeln.** In-App-Produkte, die gekauft, verwendet und dann erneut gekauft werden können. | Käufe von Verbrauchsartikeln werden aktiviert, indem ein regulärer Kauf getätigt wird und das Produkt dann mit **consumePurchase** verbraucht wird, sodass es gekauft, verwendet und dann erneut gekauft werden kann. | Verbrauchsartikel sind in iTunes Connect **als Verbrauchsartikel definiert**. | Sie unterstützen Verbrauchsartikel, indem Sie [ihren Produkttyp als „Verbrauchsartikel“ definieren, wenn Sie sie an den Store übermitteln](https://msdn.microsoft.com/library/windows/apps/mt148534.aspx). Nach dem Kauf eines Verbrauchartikels rufen Sie **[CurrentApp.ReportConsumableFulfillmentAsync](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.currentapp.reportconsumablefulfillmentasync.aspx)** auf, um dem Benutzer den Zugriff auf den Artikel zu ermöglichen.<br/><br/>[Unterstützen von Endverbraucher-In-App-Käufen](https://msdn.microsoft.com/library/windows/apps/mt219683.aspx) |
|  **Testen von In-App-Käufen.** Ermöglichen es Ihnen, den Code für In-App-Käufe zu testen, ohne Ihre App an den Store zu übermitteln. | Für Tests wird die **In-app Billing Sandbox** verwendet.  | Für Tests werden **Sandbox-Testerkonten** verwendet. | Zum Testen von In-App-Käufen können Sie einfach die **[CurrentAppSimulator](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.currentappsimulator.aspx)**-Klasse anstelle von CurrentApp verwenden.<br/><br/> |
|  **Testversionen.** Ermöglichen es Ihnen, für die Testversion einer App einfach den Inhalt zu beschränken oder Werbung zu entfernen. | **App-Testversionen werden von Google Play nicht offiziell unterstützt**. Für Testversionen oder das Entfernen von Werbung wird ein In-App-Kauf erstellt und der entsprechende Codepfad verwendet, wenn der Kauf erfolgreich bestätigt wurde. | **App-Testversionen werden vom App Store nicht offiziell unterstützt**. Für Testversionen oder das Entfernen von Werbung wird ein In-App-Kauf erstellt und der entsprechende Codepfad verwendet, wenn der Kauf erfolgreich bestätigt wurde. | Sie können eine kostenlose Testversion Ihrer App anbieten, indem Sie beim Übermitteln der App an den Store die **[Option „Kostenlose Testversion“](https://msdn.microsoft.com/library/windows/apps/mt148548.aspx)** verwenden. Anschließend können Sie mit **[LicenseInformation.IsTrial](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.licenseinformation.istrial.aspx)** den Teststatus der App überprüfen und entsprechend andere Codepfade angeben. Sie können sich für das [LicenseChanged-Ereignis](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.licenseinformation.licensechanged) registrieren, um benachrichtigt zu werden, wenn der Benutzer während der Ausführung der App den Teststatus ändert.<br/><br/>[Ausschließen oder Beschränken von Features in einer Testversion](https://msdn.microsoft.com/library/windows/apps/mt219685.aspx) |

## Anpassen an mehrere Plattformen

|  **Allgemeines Konzept** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Adaptive UI: flexible Layouts.** Unterstützen unterschiedlicher Bildschirmgrößen mit flexibler Höhe und Breite. | Flexible Layouts lassen sich mit den Werten **wrap_content** und **match_parent** in LinearLayout-Objekten oder durch Verwendung von RelativeLayout-Objekten für die Ausrichtung erstellen. | Flexible Layouts können unter Verwendung des **adaptiven Modells** mit universellen Storyboards erstellt werden, wobei **Autolayout** mit **Constraints** und **Traits**, z. B. horizontalSizeClass und displayScale, die auf Ansichtscontroller angewendet werden, genutzt wird. | Mit **Layouteigenschaften** und **Panels** sowie einer Kombination von festen und dynamischen Größen erstellen Sie ein dynamisches Layout.<br/><br/>[Definieren von Layouts mit XAML – Layouteigenschaften und -panels](https://msdn.microsoft.com/library/windows/apps/mt228350.aspx#layout_overview)<br/><br/>[Reaktionsfähiges Design für Apps für die universelle Windows Platform (UWP) – Grundlagen](https://msdn.microsoft.com/library/windows/apps/dn958435.aspx) |
|  **Adaptive UI: maßgeschneiderte Layouts.** Unterstützung unterschiedlicher Bildschirmgrößen mit eigenen Ziellayouts. | Durch die Bereitstellung alternativer Layoutdateien für unterschiedliche Bildschirmkonfigurationen im Verzeichnis „resources“ mit **Konfigurationsqualifizierern**, z. B. **small**, **large**, **ldpi** und **hdpi**, können Sie benutzerdefinierte Layouts auf Bildschirme unterschiedlicher Größe und Pixeldichte anwenden. | Definieren Sie ein **jeweils eigenes iPhone- und iPad-Storyboard**, um Layouts in einer universellen App an unterschiedliche Gerätefamilien anzupassen. | Sie können ein maßgeschneidertes Layout erstellen, indem Sie **unterschiedliche XAML-Markupdateien** pro Gerätefamilie definieren.<br/><br/>[Definieren von Layouts mit XAML – Maßgeschneiderte Layouts](https://msdn.microsoft.com/library/windows/apps/mt228350.aspx#tailored_layouts) |
|  **Adaptive UI: dynamische Layouts.** Reaktion auf Änderungen der Bildschirmgröße, z. B. Drehung, oder eine Änderung der Fenstergröße. | Dynamische Layouts werden durch die Verwendung flexibler Layouts mit **LinearLayout** und **RelativeLayout** oder das Bereitstellen alternativer Layoutdateien für unterschiedliche Ausrichtungen ermöglicht. | Wenn sich die **Größe** oder **Traits** einer Ansicht ändern, werden die in Storyboards angegebenen **Constraints** angewendet. | Mit **[VisualState](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.visualstate.aspx)**, **[VisualStateManager](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.visualstatemanager.aspx)** und **[AdaptiveTrigger](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.adaptivetrigger.aspx)** können Sie ganz einfach als Reaktion auf Änderungen der Fenstergröße zur Laufzeit Abschnitte der Benutzeroberfläche dynamisch umbrechen, neu positionieren, anzeigen, ersetzen oder ihre Größe ändern.<br/><br/>[Definieren von Layouts mit XAML – Visuelle Zustände und Zustandsauslöser](https://msdn.microsoft.com/library/windows/apps/mt228350.aspx#visual_states_and_state_triggers)<br/><br/>[Reaktionsfähiges Design für Apps für die universelle Windows Platform (UWP) – Grundlagen](https://msdn.microsoft.com/library/windows/apps/dn958435.aspx) |
|  **Unterstützen unterschiedlicher Gerätefunktionen.** Nutzen Sie erweiterte Hardwarefeatures, während Geräte, die diese nicht aufweisen, trotzdem unterstützt werden. | Durch das Testen von Gerätefeatures zur Laufzeit mit **PackageManager.hasSystemFeature** können Sie bestimmen, ob hardwarespezifischer Code ausgeführt werden kann. | Es gibt **keine einzelne Prüfung**, mit der Sie zur Laufzeit Gerätefeatures testen können. Stattdessen müssen Sie für jedes Feature spezielle Tests ausführen, um zu bestimmen, ob hardwarespezifischer Code ausgeführt werden kann. | Sie können für die Berücksichtigung zusätzlicher Funktionen in unterschiedlichen Gerätefamilien, einschließlich Smartphone, Desktop und IoT, dem Paket **Plattformerweiterungs-SDKs** hinzufügen. Mit der **[ApiInformation-API](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.apiinformation.aspx)** testen Sie zur Laufzeit, ob Typen und Member vorhanden sind, und rufen diese nur auf, wenn sie vorhanden sind. |
|  **Unterstützen unterschiedlicher Gerätefunktionen.** Nutzen Sie erweiterte Hardwarefeatures, während Geräte, die diese nicht aufweisen, trotzdem unterstützt werden. | Die **Android Support Library** kann Ihrer App hinzugefügt werden, um neuere APIs für Geräte verfügbar zu machen, auf denen ältere Versionen von Android ausgeführt werden. Das Testen der API-Ebene zur Laufzeit kann mit **Build.Version.SDK_INT** erfolgen. | Mit Standardlaufzeitprüfungen lässt sich ermitteln, ob APIs verfügbar sind. Zum Beispiel kann mit der **class**-Methode überprüft werden, ob eine Klasse vorhanden ist, und mit **respondsToSelector:** lässt sich überprüfen, ob Methoden in Klassen vorhanden sind.  | Mit **[ApiInformation.IsApiContractPresent](https://msdn.microsoft.com/library/windows/apps/dn949005.aspx)** können Sie ermitteln, ob ein API-Vertrag mit einer angegebenen Haupt- und Nebenversionsnummer vorhanden ist. Mit der **[ApiInformation-API](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.apiinformation.aspx)** testen Sie außerdem zur Laufzeit, ob Typen und Member vorhanden sind, und rufen diese nur auf, wenn sie vorhanden sind. |

## Benachrichtigungen

|  **Allgemeines Konzept** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Kacheln und Signale.** Präsentation von Updates für Benutzer auf der Startseite. | **App-Widgets** sind Ansichten in der Anwendung, die in die Startseite eingebettet werden können und regelmäßige Updates empfangen können. In Android ist **kein Signalsystem** vorhanden. Es ist kein mit Kacheln identisches System vorhanden. | In iOS gibt es **keine Kacheln oder Widgets**. Sie können dem Symbol ein **Signal** mit einer Zahl hinzufügen, die sich als Reaktion auf lokale oder Remotebenachrichtigungen ändert. | Ihre App verfügt über eine **Kachel**, die an den Startbildschirm angeheftet werden kann und in der Text und Bilder Ihrer Wahl sowie ein **Signal** mit Glyphen und Zahlen angezeigt werden. Sie können den Inhalt der Kacheln über die App aktualisieren, entweder durch Pushbenachrichtigungen oder zu vordefinierten Zeitpunkten. Kacheln können adaptiv sein und sich abhängig davon ändern, wo sie angezeigt werden.<br/><br/>[Erstellen von Kacheln](https://msdn.microsoft.com/library/windows/apps/xaml/mt185605.aspx)<br/><br/>[Erstellen adaptiver Kacheln](https://msdn.microsoft.com/library/windows/apps/xaml/mt590880.aspx)<br/><br/>[Auswählen einer Methode für die Übermittlung von Benachrichtigungen](https://msdn.microsoft.com/library/windows/apps/xaml/mt187193.aspx)<br/><br/>[Richtlinien für Kacheln und Signale](https://msdn.microsoft.com/library/windows/apps/xaml/hh465403.aspx) |
|  **Anzeigen von Benachrichtigungen.** Typen von Benachrichtigungen, die angezeigt werden können. | Benachrichtigungen können im **Benachrichtigungsbereich** und in der **Benachrichtigungsschublade** angezeigt werden. Bei **Heads-Up-Benachrichtigungen** handelt es sich um Benachrichtigungen in einem kleinen unverankerten Fenster. Den Benachrichtigungen können durch Definieren eines **PendingIntent** Aktionen hinzugefügt werden. | Popupbenachrichtigungen werden als **Banner** oder **Warnungen** angezeigt. Sie können **interaktiven Benachrichtigungen**, die mit **UIMutableUserNotificationAction** definiert werden, benutzerdefinierte Aktionsschaltflächen hinzufügen. | Sie können adaptive **Popupbenachrichtigungen** hinzufügen. Sie können in XML Popups mit visuellem Inhalt, mit **Aktionen**, bei denen es sich um Schaltflächen handeln kann, oder mit Eingaben und Audioinhalten definieren.<br/><br/>[Adaptive und interaktive Popupbenachrichtigungen](https://msdn.microsoft.com/library/windows/apps/xaml/mt631604.aspx)<br/><br/>[Auswählen einer Methode für die Übermittlung von Benachrichtigungen](https://msdn.microsoft.com/library/windows/apps/xaml/mt187193.aspx)<br/><br/>[Richtlinien für Popupbenachrichtigungen](https://msdn.microsoft.com/library/windows/apps/xaml/hh465391.aspx) |
|  **Planen von lokalen Benachrichtigungen.** Lokale Benachrichtigungen, die von der App zu einem geplanten Zeitpunkt gesendet werden. | Benachrichtigungen und Aktionen werden mit einem **NotificationCompat.Builder** definiert. Sie können mit **AlarmManager** und **BroadcastReceiver** in der App geplant und behandelt werden. | Lokale Benachrichtigungen werden mit **UILocalNotification** erstellt und können mit ** UILocalNotification.scheduleLocalNotification:** geplant werden. | Sie können Popupbenachrichtigungen mit **[ScheduledToastNotification](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.notifications.scheduledtoastnotification.aspx)** planen. Sie können mit der **[TileNotification-Klasse](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.notifications.tilenotification.aspx)** eine Kachelbenachrichtigung von der App senden oder mit [ScheduledTileNotification](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.notifications.scheduledtilenotification.aspx) eine Kachelbenachrichtigung planen.<br/><br/>[Adaptive und interaktive Popupbenachrichtigungen](https://msdn.microsoft.com/library/windows/apps/xaml/mt631604.aspx)<br/><br/>[Senden einer lokalen Kachelbenachrichtigung](https://msdn.microsoft.com/library/windows/apps/xaml/mt593299.aspx) |
|  **Senden von Pushbenachrichtigungen.** Von einem Pushbenachrichtigungsserver wird eine Benachrichtigung gesendet, die optional in der App behandelt wird. | **Google Cloud Messaging** unterstützt Pushbenachrichtigungen für Android. | Vom **Apple Push-Benachrichtigungsdienst (APNs)** werden Remote- oder Pushbenachrichtigungen bereitgestellt. | Sie empfangen von den **Windows-Pushbenachrichtigungsdiensten (Windows Push Notification Services, WNS)** gesendete Pushbenachrichtigungen, die vom Typ Kachel oder Signal sein können oder als Popup- oder unformatierte Benachrichtigungen gesendet werden. Sie können das [PushNotificationReceived](https://msdn.microsoft.com/library/windows/apps/xaml/windows.networking.pushnotifications.pushnotificationchannel.pushnotificationreceived.aspx)-Benachrichtigungsübermittlungsereignis verwenden, um Benachrichtigungen zu empfangen, während die App ausgeführt wird.<br/><br/>[Übersicht über die Windows-Pushbenachrichtigungsdienste (Windows Push Notification Services, WNS)](https://msdn.microsoft.com/library/windows/apps/xaml/mt187203.aspx)<br/><br/>[Übersicht über unformatierte Benachrichtigungen](https://msdn.microsoft.com/library/windows/apps/xaml/mt187200.aspx) |

## Medienaufzeichnung und -rendering

|  **Allgemeines Konzept** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Aufzeichnen von Medien.** Aufzeichnen von Audio- und visuellen Inhalten. | Mithilfe eines **Intents**, z. B. MediaStore.ACTION_VIDEO_CAPTURE, können Medien mit einer vorhandenen Kamera-App aufgezeichnet werden. Die Bibliothek **android.hardware.camera2** oder **camera** ermöglicht die Implementierung einer benutzerdefinierten Kameraschnittstelle. Für die Audioaufzeichnung können **MediaRecorder**-APIs verwendet werden. | Der **UIImagePickerController** ermöglicht das Aufzeichnen von Videos und Fotos mit der Benutzeroberfläche des Systems. Die **AVFoundation**-Klassen, z. B. **AVCaptureSession**, aktivieren den direkten Zugriff auf die Kamera. <br/>Die **AVAudioRecorder**-Klasse ermöglicht die Audioaufzeichnung. | Mit der **[CameraCaptureUI-Klasse](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.capture.cameracaptureui.aspx)** können Sie Fotos und Videos unter Verwendung der integrierten Kamera-UI aufzeichnen. Sie können auf einer niedrigen Ebene mit der Kamera interagieren und Klassen in **[Windows.Media.Capture](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.capture.aspx)**, z. B. die **[MediaCapture-API](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.capture.mediacapture.aspx)**, für die Audioaufzeichnung verwenden. <br/><br/>[Aufnehmen von Fotos und Videos mit CameraCaptureUI](https://msdn.microsoft.com/library/windows/apps/xaml/mt282142.aspx)<br/><br/>[Aufnehmen von Fotos und Videos mit MediaCapture](https://msdn.microsoft.com/library/windows/apps/xaml/mt243896.aspx) |
|  **Medienwiedergabe.** Wiedergeben von Audio- und Videodateien. | Zum Wiedergeben von Audio- und Videodateien werden die **MediaPlayer**-Klasse und die **AudioManager**-Klasse verwendet. | Zum Wiedergeben von Audio- und Videodateien werden das **AVKit-Framework**, **AVAudioPlayer** und das **Media Player-Framework** verwendet. | Sie können mit den Klassen **[MediaSource](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.core.mediasource.aspx)**, **[MediaElement](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaelement.aspx)** und **[MediaPlayer](https://msdn.microsoft.com/library/windows/apps/windows.media.playback.mediaplayer.aspx)** Audio- und Videodateien aus Quellen, z. B. lokalen und Remotedateien, wiedergeben.<br/><br/>[Medienwiedergabe mit „MediaSource“](https://msdn.microsoft.com/library/windows/apps/xaml/mt592657.aspx) |
|  **Bearbeiten von Medien.** Erstellen neuer Mediendateien aus vorhandenen Aufzeichnungen und Anwenden von Spezialeffekten. | Zum Bearbeiten von Inhalten können Klassen niedriger Ebene, z. B. **MediaCodec**, **MediaMuxer** und **android.media.effect**, verwendet werden. | Zum Bearbeiten von Inhalten können Klassen im **AV Foundation**-Framework, z. B. **AVMutableComposition**, **AVMutableVideoComposition** und **AVMutableAudioMix**, verwendet werden. | Sie können mit den **[Windows.Media.Editing](https://msdn.microsoft.com/library/windows/apps/windows.media.editing.aspx)**-APIs, z. B. **[MediaComposition](https://msdn.microsoft.com/library/windows/apps/windows.media.editing.mediacomposition.aspx)** und **[MediaClip](https://msdn.microsoft.com/library/windows/apps/windows.media.editing.mediaclip.aspx)**, Medienkompositionen aus Audio- und Videodateien erstellen. Sie können Video- und Bildüberlagerungen hinzufügen, Videoclips kombinieren, Hintergrundaudio hinzufügen und Audio- und Videoeffekte anwenden.<br/><br/>[Medienkompositionen und -bearbeitung](https://msdn.microsoft.com/library/windows/apps/mt204792.aspx) |

## Sensoren

|  **Allgemeines Konzept** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Sensoren.** Erkennen der Bewegung, Position und Umwelteigenschaften des Geräts. | Das **Sensor-Framework** wird für den Zugriff auf Hardware- und Softwaresensoren mit Klassen, z. B. **SensorManager** und **SensorEvent**, verwendet.  | Das **Core Motion Framework** wird für den Zugriff auf Sensorrohdaten und verarbeitete Sensordaten verwendet. | Sie können Klassen in **[Windows.Devices.Sensors](https://msdn.microsoft.com/library/windows/apps/windows.devices.sensors.aspx)** für den Zugriff auf Sensorwerte und Ereignisse verwenden, die ausgelöst werden, wenn der Sensor neue Messungsdaten empfängt.<br/><br/>[Sensoren](https://msdn.microsoft.com/library/windows/apps/xaml/mt187358.aspx) |

## Position und Kartenfunktionen

|  **Allgemeines Konzept** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Position.** Suchen der **aktuellen** Position des Geräts und Nachverfolgen von **Änderungen**. | Die Standort-APIs der Google Play-Dienste bieten mit dem **Fused Location Provider** unter Verwendung der **getLastLocation**-Methode und der **requestLocationUpdates**-Methode High-Level-Zugriff auf die **letzte bekannte Position**. Low-Level-Zugriff wird in den Android-Bibliotheken mit dem **LocationManager** bereitgestellt. | Die **CLLocationManager**-Klasse von **Core Location** wird zum Überwachen der Position eines Geräts verwendet, mit **startUpdatingLocation** für den Standardstandortdienst und **startMonitoringSignificantLocationChanges** für den **significant-change**-Standortdienst. | Sie können die Geräteposition mit Klassen in **[Windows.Devices.Geolocation](https://msdn.microsoft.com/library/windows/apps/windows.devices.geolocation.aspx)** nachverfolgen. Verwenden Sie für einmaliges Lesen **[Geolocator.GetGeopositionAsync](https://msdn.microsoft.com/library/windows/apps/br225537.aspx)**. Verwenden Sie **[Geolocator.PositionChanged](https://msdn.microsoft.com/library/windows/apps/windows.devices.geolocation.geolocator.positionchanged.aspx)**, um die Position mithilfe eines Timers regelmäßig abzurufen oder um informiert zu werden, wenn sich die Position ändert.<br/><br/>[Abrufen der Position eines Benutzers](https://msdn.microsoft.com/library/windows/apps/mt219698.aspx) |
|  **Anzeigen von Karten.** Anzeigen einer **interaktiven integrierten Karte** und Hinzufügen von **interessanten Orten**. | Die Klassen **GoogleMap**, **MapFragment** und **MapView** in der **Google Maps Android API** ermöglichen das Einbetten von Karten in Apps. Interessante Orte können mit **Markern** und der anpassbaren **Marker**-Klasse angezeigt werden. | Karten werden mit der **MKMapView**-Klasse im **MapKit-Framework** in iOS-Apps eingebettet. Mit Objektklassen, z. B. **MKPointAnnotation**, und Ansichtsklassen, z. B. **MKPinAnnotationView**, können den Apps **Anmerkungen** hinzugefügt werden, um interessante Orte anzuzeigen. | Sie können mit dem integrierten **[MapControl](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mapcontrol.aspx)**-XAML-Steuerelement, das 2D-, 3D- und Streetside-Ansichten bereitstellt, Karten in die Apps einbetten. Mit Klassen wie **[MapIcon](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mapicon.aspx)**, **[MapPolygon](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mappolygon.aspx)** und **[MapPolyline](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mappolyline.aspx)** können Sie interessante Orte mit einer Ortsmarke, einem Bild oder eine Form hinzufügen.<br/><br/>[Anzeigen von Karten mit 2D-, 3D- und Streetside-Ansichten](https://msdn.microsoft.com/library/windows/apps/mt219695.aspx)<br/><br/>[Anzeigen von interessanten Orten (POI) auf einer Karte](https://msdn.microsoft.com/library/windows/apps/mt219696.aspx) |
|  **Geofencing.** Überwachen des Betretens und Verlassens einer bestimmten geografischen Region. | Geofences werden mit den **Location Services** im Google Play Services SDK überwacht. | Regionen werden mit der **CLCircularRegion**-Klasse überwacht und mit der **CLLocationManager.startMonitoringForRegion:**-Methode registriert. | Sie können einen Geofence-Bereich mit der **[Geofence](https://msdn.microsoft.com/library/windows/apps/windows.devices.geolocation.geofencing.geofence.aspx)**-Klasse erstellen und **überwachte Zustände**, z. B. das Betreten oder Verlassen einer Region, definieren. Mit der **[GeofenceMonitor-Klasse](https://msdn.microsoft.com/library/windows/apps/windows.devices.geolocation.geofencing.geofencemonitor.aspx)** behandeln Sie Geofence-Ereignisse im Vordergrund und mit der **[LocationTrigger-Hintergrundklasse](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.background.locationtrigger.aspx)** im Hintergrund.<br/><br/>[Einrichten von Geofence-Bereichen](https://msdn.microsoft.com/library/windows/apps/mt219702.aspx) |
|  **Geocodierung und umgekehrte Geocodierung.** Das Umwandeln von Adressen in geografische Standorte (Geocodierung) und das Umwandeln geografischer Standorte in Adressen (umgekehrte Geocodierung).<br/> | Für Geocodierung und umgekehrte Geocodierung wird die **Geocoder**-Klasse verwendet. | Für Geocodierung wird die **CLGeocoder**-Klasse verwendet. | Sie können Geocodierung mit der **[MapLocationFinder-Klasse](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maplocationfinder.aspx)** in **[Windows.Services.Maps](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.aspx)** ausführen. Sie verwenden **[FindLocationsAsync](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maplocationfinder.findlocationsasync.aspx)** für Geocodierung und **[FindLocationsAtAsync](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maplocationfinder.findlocationsatasync.aspx)** für umgekehrte Geocodierung.<br/><br/>[Durchführen der Geocodierung und umgekehrten Geocodierung](https://msdn.microsoft.com/library/windows/apps/mt219697.aspx) |
|  **Routen und Wegbeschreibungen.** Bereitstellen von Routen und Entfernungen zwischen zwei geografische Standorten und der entsprechenden Wegbeschreibungen. | Google bietet den Webdienst **Google Maps Directions API**, der in Android verwendet werden kann, obwohl kein SDK verfügbar ist. | MapKit stellt die **MKDirections**-API bereit, mit der Informationen zu einer Route und Wegbeschreibungen abgerufen werden können. | Sie können mit der **[MapRouteFinder](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maproutefinder.aspx)**-Klasse in **[Windows.Services.Maps](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.aspx)** eine Fußgänger -oder Autoroute anfordern. Routen werden als **[MapRoute](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maproute.aspx)**-Instanz zurückgegeben, die einfach in einem MapControl angezeigt werden kann. Wegbeschreibungen werden im **[MapRouteManeuver](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maproutemaneuver.aspx)**-Objekt zurückgegeben.<br/><br/>[Anzeigen von Routen und Wegbeschreibungen auf einer Karte](https://msdn.microsoft.com/library/windows/apps/mt219701.aspx) |

## App-zu-App-Kommunikation

|  **Allgemeines Konzept** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Aufrufen einer anderen App.** Das Starten einer anderen App und optional das Freigeben von Daten, z. B. Links, Text, Fotos, Videos und Dateien. | Zum Starten einer anderen App wird ein **impliziter Intent** verwendet. Dabei werden eine **Action** und optionale Daten in einem **Intent** definiert und mit **startActivityForResult** aufgerufen.<br/> | Mit **App-Erweiterungen** kann der Zugriff auf App-Daten für eine andere App bereitgestellt werden. **URL-Schemas** ermöglichen das Übergeben einer URL an eine andere App. | Sie können mit **[Launcher.LaunchUriAsync](https://msdn.microsoft.com/library/windows/apps/windows.system.launcher.launchuriasync.aspx)** eine andere App aufrufen, die sich für einen URI registriert hat, oder **[Launcher.LaunchUriForResultsAsync](https://msdn.microsoft.com/library/windows/apps/windows.system.launcher.launchuriforresultsasync.aspx)** verwenden, um eine andere App aufzurufen und Ergebnisse von dieser abzurufen. Sie können mit **[Launcher.LaunchFileAsync](https://msdn.microsoft.com/library/windows/apps/hh701471.aspx)** eine Datei an eine andere App übergeben, damit sie von dieser behandelt wird.<br/><br/>Zum Freigeben von Daten zwischen Apps können Sie einfach einen **Freigabe-Vertrag** verwenden.<br/><br/>[Starten der Standard-App für einen URI](https://msdn.microsoft.com/library/windows/apps/mt228340.aspx)<br/><br/>[Starten einer App für Ergebnisse](https://msdn.microsoft.com/library/windows/apps/mt269386.aspx)<br/><br/>[Starten der Standard-App für eine Datei](https://msdn.microsoft.com/library/windows/apps/mt299102.aspx)<br/><br/>[Freigeben von Daten](https://msdn.microsoft.com/library/windows/apps/xaml/mt243293.aspx) |
|  **Zulassen des Aufrufs der App.** Zulassen, dass Ihre App auf eine Anforderung von einer anderen App antwortet. | Apps registrieren eine **Intent-Behandlungsaktivität** bei einem **Intent-Filter**, um auf einen impliziten Intent von einer anderen App zu reagieren. | Durch das Verpacken einer **App-Erweiterung** können Daten für andere Apps freigegeben werden. Apps können mit dem Schlüssel **CFBundleURLTypes** in „Info.plist“ ein **benutzerdefiniertes URL-Schema** registrieren. | Sie können Ihre App als Standardhandler für einen **URI-Schemanamen** registrieren, indem Sie ein **[Protokoll](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.activation.activationkind.aspx#Protocol)** im Paketmanifest registrieren und den **[Application.OnActivated](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.application.onactivated.aspx)**-Ereignishandler aktualisieren. Optional werden Ergebnisse zurückgegeben. Auf die gleiche Weise können Sie Ihre App als Standardhandler für bestimmte Dateitypen registrieren, indem Sie im Paketmanifest eine Deklaration hinzufügen und das **[Application.OnFileActivated](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.application.onfileactivated.aspx)**-Ereignis behandeln.<br/><br/>Sie können die Freigabe-Vertrag-Anforderungen behandeln, indem Sie die App im Manifest als Freigabeziel registrieren und das **[Application.OnShareTargetActivated](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.application.onsharetargetactivated.aspx)**-Ereignis behandeln.<br/><br/>[Starten einer App für Ergebnisse](https://msdn.microsoft.com/library/windows/apps/mt269386.aspx)<br/><br/>[Behandeln der Dateiaktivierung](https://msdn.microsoft.com/library/windows/apps/mt269385.aspx)<br/><br/>[Empfangen von Daten](https://msdn.microsoft.com/library/windows/apps/xaml/mt243292.aspx) |
|  **Kopieren und Einfügen.** Kopieren und Einfügen von Text und anderen Inhalten zwischen Apps. | Das **Clipboard Framework** kann verwendet werden, um Kopieren und Einfügen mit der **ClipboardManager**-Klasse und der **ClipData**-Klasse zu implementieren. | Zum Implementieren von Kopieren und Einfügen können **UIPasteboard**, **UIMenuController** und **UIResponderStandardEditActions** verwendet werden. | Viele Standard-XAML-Steuerelemente unterstützen bereits Kopieren und Einfügen. Sie können mithilfe der **[DataPackage](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.datatransfer.datapackage.aspx)**-Klasse und der **[Clipboard](https://msdn.microsoft.com/library/windows/apps/xaml/windows.applicationmodel.datatransfer.clipboard.aspx)**-Klasse in **[Windows.ApplicationModel.DataTransfer](https://msdn.microsoft.com/library/windows/apps/br205967)** Kopieren und Einfügen selbst implementieren.<br/><br/>[Kopieren und Einfügen](https://msdn.microsoft.com/library/windows/apps/xaml/mt243291.aspx) |
|  **Drag & Drop.** Drag & Drop von Inhalten zwischen Apps. | Drag & Drop kann mit dem **Android Drag/Drop Framework** in einer einzelnen Anwendung implementiert werden. | Von iOS werden keine allgemeinen Drag & Drop-APIs bereitgestellt. | Sie können in der App Drag & Drop implementieren, um Drag & Drop-Funktionen von App zu App, von Desktop zu App und von App zu Desktop zu ermöglichen. Sie können in der UIElement-Klasse mit der **[AllowDrop](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.allowdrop.aspx)**-Eigenschaft und der **[CanDrag](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.candrag.aspx)**-Eigenschaft sowie mit dem **[DragOver](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.dragover.aspx)**-Ereignis und dem **[Drop](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.drop.aspx)**-Ereignis Unterstützung für Drag & Drop implementieren.<br/><br/>[Drag & Drop](https://msdn.microsoft.com/library/windows/apps/xaml/mt227651.aspx) |

## Softwaredesign

|  **Allgemeines Konzept** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Softwaredesignmuster.** Empfohlene oder perfekt verwendete Muster für die Plattform. | Für die Android-Entwicklung wurde kein formales Musters empfohlen oder bereitgestellt, jedoch ermöglicht eventuell die Betaversion des Data Binding Frameworks die häufigere Verwendung des **Model-View-ViewModel (MVVM)**-Musters. In einer Reihe von Drittanbieterartikeln und -Frameworks werden die Ansätze **Model-View-Presenter (MVP)** und **MVVM** empfohlen. | **Model-View-Controller (MVC)** ist ein häufig verwendetes Muster für iOS und in die Plattform integriert. | Sie sind beim Softwaredesign für UWP nicht auf ein bestimmtes Muster beschränkt.<br/><br/>Sie können das integrierte [Datenbindungsmuster](https://msdn.microsoft.com/library/windows/apps/mt210947.aspx) verwenden, um eine deutliche Trennung von Datenaspekten und UI-Aspekten sicherzustellen und zu vermeiden, dass Sie UI-Ereignishandler programmieren müssen, die Eigenschaftswerte aktualisieren.<br/><br/>Sie können die Datenbindung auf die Befolgung des **Model-View-ViewModel (MVVM)**-Musters erweitern, indem Sie MVVM-Bibliotheken von Drittanbietern, z. B. das [MVVM Light Toolkit](https://mvvmlight.codeplex.com/), nutzen, oder eine eigene Bibliothek verwenden und Logik von der CodeBehind-Datei fernhalten.<br/><br/>[Das MVVM-Muster](https://msdn.microsoft.com/library/hh848246.aspx)<br/><br/>[Visual Studio-Template 10-Projektvorlagen](https://github.com/Windows-XAML/Template10/wiki) |


<!--HONumber=Mar16_HO1-->


